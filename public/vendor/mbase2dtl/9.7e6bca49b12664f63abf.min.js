(window["webpackJsonpmbase2modules"] = window["webpackJsonpmbase2modules"] || []).push([[9],{

/***/ 124:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function(exports){

    // Array.prototype.map polyfill
    // code from https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/map
    if (!Array.prototype.map){
        Array.prototype.map = function(fun /*, thisArg */){
            "use strict";

            if (this === void 0 || this === null)
                throw new TypeError();

            var t = Object(this);
            var len = t.length >>> 0;
            if (typeof fun !== "function")
                throw new TypeError();

            var res = new Array(len);
            var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
            for (var i = 0; i < len; i++)
            {
                // NOTE: Absolute correctness would demand Object.defineProperty
                //       be used.  But this method is fairly new, and failure is
                //       possible only if Object.prototype or Array.prototype
                //       has a property |i| (very unlikely), so use a less-correct
                //       but more portable alternative.
                if (i in t)
                    res[i] = fun.call(thisArg, t[i], i, t);
            }

            return res;
        };
    }

    var A = 'A'.charCodeAt(0),
        Z = 'Z'.charCodeAt(0);

    /**
     * Prepare an IBAN for mod 97 computation by moving the first 4 chars to the end and transforming the letters to
     * numbers (A = 10, B = 11, ..., Z = 35), as specified in ISO13616.
     *
     * @param {string} iban the IBAN
     * @returns {string} the prepared IBAN
     */
    function iso13616Prepare(iban) {
        iban = iban.toUpperCase();
        iban = iban.substr(4) + iban.substr(0,4);

        return iban.split('').map(function(n){
            var code = n.charCodeAt(0);
            if (code >= A && code <= Z){
                // A = 10, B = 11, ... Z = 35
                return code - A + 10;
            } else {
                return n;
            }
        }).join('');
    }

    /**
     * Calculates the MOD 97 10 of the passed IBAN as specified in ISO7064.
     *
     * @param iban
     * @returns {number}
     */
    function iso7064Mod97_10(iban) {
        var remainder = iban,
            block;

        while (remainder.length > 2){
            block = remainder.slice(0, 9);
            remainder = parseInt(block, 10) % 97 + remainder.slice(block.length);
        }

        return parseInt(remainder, 10) % 97;
    }

    /**
     * Parse the BBAN structure used to configure each IBAN Specification and returns a matching regular expression.
     * A structure is composed of blocks of 3 characters (one letter and 2 digits). Each block represents
     * a logical group in the typical representation of the BBAN. For each group, the letter indicates which characters
     * are allowed in this group and the following 2-digits number tells the length of the group.
     *
     * @param {string} structure the structure to parse
     * @returns {RegExp}
     */
    function parseStructure(structure){
        // split in blocks of 3 chars
        var regex = structure.match(/(.{3})/g).map(function(block){

            // parse each structure block (1-char + 2-digits)
            var format,
                pattern = block.slice(0, 1),
                repeats = parseInt(block.slice(1), 10);

            switch (pattern){
                case "A": format = "0-9A-Za-z"; break;
                case "B": format = "0-9A-Z"; break;
                case "C": format = "A-Za-z"; break;
                case "F": format = "0-9"; break;
                case "L": format = "a-z"; break;
                case "U": format = "A-Z"; break;
                case "W": format = "0-9a-z"; break;
            }

            return '([' + format + ']{' + repeats + '})';
        });

        return new RegExp('^' + regex.join('') + '$');
    }

    /**
     *
     * @param iban
     * @returns {string}
     */
    function electronicFormat(iban){
        return iban.replace(NON_ALPHANUM, '').toUpperCase();
    }


    /**
     * Create a new Specification for a valid IBAN number.
     *
     * @param countryCode the code of the country
     * @param length the length of the IBAN
     * @param structure the structure of the underlying BBAN (for validation and formatting)
     * @param example an example valid IBAN
     * @constructor
     */
    function Specification(countryCode, length, structure, example){

        this.countryCode = countryCode;
        this.length = length;
        this.structure = structure;
        this.example = example;
    }

    /**
     * Lazy-loaded regex (parse the structure and construct the regular expression the first time we need it for validation)
     */
    Specification.prototype._regex = function(){
        return this._cachedRegex || (this._cachedRegex = parseStructure(this.structure))
    };

    /**
     * Check if the passed iban is valid according to this specification.
     *
     * @param {String} iban the iban to validate
     * @returns {boolean} true if valid, false otherwise
     */
    Specification.prototype.isValid = function(iban){
        return this.length == iban.length
            && this.countryCode === iban.slice(0,2)
            && this._regex().test(iban.slice(4))
            && iso7064Mod97_10(iso13616Prepare(iban)) == 1;
    };

    /**
     * Convert the passed IBAN to a country-specific BBAN.
     *
     * @param iban the IBAN to convert
     * @param separator the separator to use between BBAN blocks
     * @returns {string} the BBAN
     */
    Specification.prototype.toBBAN = function(iban, separator) {
        return this._regex().exec(iban.slice(4)).slice(1).join(separator);
    };

    /**
     * Convert the passed BBAN to an IBAN for this country specification.
     * Please note that <i>"generation of the IBAN shall be the exclusive responsibility of the bank/branch servicing the account"</i>.
     * This method implements the preferred algorithm described in http://en.wikipedia.org/wiki/International_Bank_Account_Number#Generating_IBAN_check_digits
     *
     * @param bban the BBAN to convert to IBAN
     * @returns {string} the IBAN
     */
    Specification.prototype.fromBBAN = function(bban) {
        if (!this.isValidBBAN(bban)){
            throw new Error('Invalid BBAN');
        }

        var remainder = iso7064Mod97_10(iso13616Prepare(this.countryCode + '00' + bban)),
            checkDigit = ('0' + (98 - remainder)).slice(-2);

        return this.countryCode + checkDigit + bban;
    };

    /**
     * Check of the passed BBAN is valid.
     * This function only checks the format of the BBAN (length and matching the letetr/number specs) but does not
     * verify the check digit.
     *
     * @param bban the BBAN to validate
     * @returns {boolean} true if the passed bban is a valid BBAN according to this specification, false otherwise
     */
    Specification.prototype.isValidBBAN = function(bban) {
        return this.length - 4 == bban.length
            && this._regex().test(bban);
    };

    var countries = {};

    function addSpecification(IBAN){
        countries[IBAN.countryCode] = IBAN;
    }

    addSpecification(new Specification("AD", 24, "F04F04A12",          "AD1200012030200359100100"));
    addSpecification(new Specification("AE", 23, "F03F16",             "AE070331234567890123456"));
    addSpecification(new Specification("AL", 28, "F08A16",             "AL47212110090000000235698741"));
    addSpecification(new Specification("AT", 20, "F05F11",             "AT611904300234573201"));
    addSpecification(new Specification("AZ", 28, "U04A20",             "AZ21NABZ00000000137010001944"));
    addSpecification(new Specification("BA", 20, "F03F03F08F02",       "BA391290079401028494"));
    addSpecification(new Specification("BE", 16, "F03F07F02",          "BE68539007547034"));
    addSpecification(new Specification("BG", 22, "U04F04F02A08",       "BG80BNBG96611020345678"));
    addSpecification(new Specification("BH", 22, "U04A14",             "BH67BMAG00001299123456"));
    addSpecification(new Specification("BR", 29, "F08F05F10U01A01",    "BR9700360305000010009795493P1"));
    addSpecification(new Specification("BY", 28, "A04F04A16",          "BY13NBRB3600900000002Z00AB00"));
    addSpecification(new Specification("CH", 21, "F05A12",             "CH9300762011623852957"));
    addSpecification(new Specification("CR", 22, "F04F14",             "CR72012300000171549015"));
    addSpecification(new Specification("CY", 28, "F03F05A16",          "CY17002001280000001200527600"));
    addSpecification(new Specification("CZ", 24, "F04F06F10",          "CZ6508000000192000145399"));
    addSpecification(new Specification("DE", 22, "F08F10",             "DE89370400440532013000"));
    addSpecification(new Specification("DK", 18, "F04F09F01",          "DK5000400440116243"));
    addSpecification(new Specification("DO", 28, "U04F20",             "DO28BAGR00000001212453611324"));
    addSpecification(new Specification("EE", 20, "F02F02F11F01",       "EE382200221020145685"));
    addSpecification(new Specification("EG", 29, "F04F04F17",          "EG800002000156789012345180002"));
    addSpecification(new Specification("ES", 24, "F04F04F01F01F10",    "ES9121000418450200051332"));
    addSpecification(new Specification("FI", 18, "F06F07F01",          "FI2112345600000785"));
    addSpecification(new Specification("FO", 18, "F04F09F01",          "FO6264600001631634"));
    addSpecification(new Specification("FR", 27, "F05F05A11F02",       "FR1420041010050500013M02606"));
    addSpecification(new Specification("GB", 22, "U04F06F08",          "GB29NWBK60161331926819"));
    addSpecification(new Specification("GE", 22, "U02F16",             "GE29NB0000000101904917"));
    addSpecification(new Specification("GI", 23, "U04A15",             "GI75NWBK000000007099453"));
    addSpecification(new Specification("GL", 18, "F04F09F01",          "GL8964710001000206"));
    addSpecification(new Specification("GR", 27, "F03F04A16",          "GR1601101250000000012300695"));
    addSpecification(new Specification("GT", 28, "A04A20",             "GT82TRAJ01020000001210029690"));
    addSpecification(new Specification("HR", 21, "F07F10",             "HR1210010051863000160"));
    addSpecification(new Specification("HU", 28, "F03F04F01F15F01",    "HU42117730161111101800000000"));
    addSpecification(new Specification("IE", 22, "U04F06F08",          "IE29AIBK93115212345678"));
    addSpecification(new Specification("IL", 23, "F03F03F13",          "IL620108000000099999999"));
    addSpecification(new Specification("IS", 26, "F04F02F06F10",       "IS140159260076545510730339"));
    addSpecification(new Specification("IT", 27, "U01F05F05A12",       "IT60X0542811101000000123456"));
    addSpecification(new Specification("IQ", 23, "U04F03A12",          "IQ98NBIQ850123456789012"));
    addSpecification(new Specification("JO", 30, "A04F22",             "JO15AAAA1234567890123456789012"));
    addSpecification(new Specification("KW", 30, "U04A22",             "KW81CBKU0000000000001234560101"));
    addSpecification(new Specification("KZ", 20, "F03A13",             "KZ86125KZT5004100100"));
    addSpecification(new Specification("LB", 28, "F04A20",             "LB62099900000001001901229114"));
    addSpecification(new Specification("LC", 32, "U04F24",             "LC07HEMM000100010012001200013015"));
    addSpecification(new Specification("LI", 21, "F05A12",             "LI21088100002324013AA"));
    addSpecification(new Specification("LT", 20, "F05F11",             "LT121000011101001000"));
    addSpecification(new Specification("LU", 20, "F03A13",             "LU280019400644750000"));
    addSpecification(new Specification("LV", 21, "U04A13",             "LV80BANK0000435195001"));
    addSpecification(new Specification("MC", 27, "F05F05A11F02",       "MC5811222000010123456789030"));
    addSpecification(new Specification("MD", 24, "U02A18",             "MD24AG000225100013104168"));
    addSpecification(new Specification("ME", 22, "F03F13F02",          "ME25505000012345678951"));
    addSpecification(new Specification("MK", 19, "F03A10F02",          "MK07250120000058984"));
    addSpecification(new Specification("MR", 27, "F05F05F11F02",       "MR1300020001010000123456753"));
    addSpecification(new Specification("MT", 31, "U04F05A18",          "MT84MALT011000012345MTLCAST001S"));
    addSpecification(new Specification("MU", 30, "U04F02F02F12F03U03", "MU17BOMM0101101030300200000MUR"));
    addSpecification(new Specification("NL", 18, "U04F10",             "NL91ABNA0417164300"));
    addSpecification(new Specification("NO", 15, "F04F06F01",          "NO9386011117947"));
    addSpecification(new Specification("PK", 24, "U04A16",             "PK36SCBL0000001123456702"));
    addSpecification(new Specification("PL", 28, "F08F16",             "PL61109010140000071219812874"));
    addSpecification(new Specification("PS", 29, "U04A21",             "PS92PALS000000000400123456702"));
    addSpecification(new Specification("PT", 25, "F04F04F11F02",       "PT50000201231234567890154"));
    addSpecification(new Specification("QA", 29, "U04A21",             "QA30AAAA123456789012345678901"));
    addSpecification(new Specification("RO", 24, "U04A16",             "RO49AAAA1B31007593840000"));
    addSpecification(new Specification("RS", 22, "F03F13F02",          "RS35260005601001611379"));
    addSpecification(new Specification("SA", 24, "F02A18",             "SA0380000000608010167519"));
    addSpecification(new Specification("SC", 31, "U04F04F16U03",       "SC18SSCB11010000000000001497USD"));
    addSpecification(new Specification("SE", 24, "F03F16F01",          "SE4550000000058398257466"));
    addSpecification(new Specification("SI", 19, "F05F08F02",          "SI56263300012039086"));
    addSpecification(new Specification("SK", 24, "F04F06F10",          "SK3112000000198742637541"));
    addSpecification(new Specification("SM", 27, "U01F05F05A12",       "SM86U0322509800000000270100"));
    addSpecification(new Specification("ST", 25, "F08F11F02",          "ST68000100010051845310112"));
    addSpecification(new Specification("SV", 28, "U04F20",             "SV62CENR00000000000000700025"));
    addSpecification(new Specification("TL", 23, "F03F14F02",          "TL380080012345678910157"));
    addSpecification(new Specification("TN", 24, "F02F03F13F02",       "TN5910006035183598478831"));
    addSpecification(new Specification("TR", 26, "F05F01A16",          "TR330006100519786457841326"));
    addSpecification(new Specification("UA", 29, "F25",                "UA511234567890123456789012345"));
    addSpecification(new Specification("VA", 22, "F18",                "VA59001123000012345678"));
    addSpecification(new Specification("VG", 24, "U04F16",             "VG96VPVG0000012345678901"));
    addSpecification(new Specification("XK", 20, "F04F10F02",          "XK051212012345678906"));


    // The following countries are not included in the official IBAN registry but use the IBAN specification

    // Angola
    addSpecification(new Specification("AO", 25, "F21",                "AO69123456789012345678901"));
    // Burkina
    addSpecification(new Specification("BF", 27, "F23",                "BF2312345678901234567890123"));
    // Burundi
    addSpecification(new Specification("BI", 16, "F12",                "BI41123456789012"));
    // Benin
    addSpecification(new Specification("BJ", 28, "F24",                "BJ39123456789012345678901234"));
    // Ivory
    addSpecification(new Specification("CI", 28, "U02F22",             "CI70CI1234567890123456789012"));
    // Cameron
    addSpecification(new Specification("CM", 27, "F23",                "CM9012345678901234567890123"));
    // Cape Verde
    addSpecification(new Specification("CV", 25, "F21",                "CV30123456789012345678901"));
    // Algeria
    addSpecification(new Specification("DZ", 24, "F20",                "DZ8612345678901234567890"));
    // Iran
    addSpecification(new Specification("IR", 26, "F22",                "IR861234568790123456789012"));
    // Madagascar
    addSpecification(new Specification("MG", 27, "F23",                "MG1812345678901234567890123"));
    // Mali
    addSpecification(new Specification("ML", 28, "U01F23",             "ML15A12345678901234567890123"));
    // Mozambique
    addSpecification(new Specification("MZ", 25, "F21",                "MZ25123456789012345678901"));
    // Senegal
    addSpecification(new Specification("SN", 28, "U01F23",             "SN52A12345678901234567890123"));

    // The following are regional and administrative French Republic subdivision IBAN specification (same structure as FR, only country code vary)
    addSpecification(new Specification("GF", 27, "F05F05A11F02",       "GF121234512345123456789AB13"));
    addSpecification(new Specification("GP", 27, "F05F05A11F02",       "GP791234512345123456789AB13"));
    addSpecification(new Specification("MQ", 27, "F05F05A11F02",       "MQ221234512345123456789AB13"));
    addSpecification(new Specification("RE", 27, "F05F05A11F02",       "RE131234512345123456789AB13"));
    addSpecification(new Specification("PF", 27, "F05F05A11F02",       "PF281234512345123456789AB13"));
    addSpecification(new Specification("TF", 27, "F05F05A11F02",       "TF891234512345123456789AB13"));
    addSpecification(new Specification("YT", 27, "F05F05A11F02",       "YT021234512345123456789AB13"));
    addSpecification(new Specification("NC", 27, "F05F05A11F02",       "NC551234512345123456789AB13"));
    addSpecification(new Specification("BL", 27, "F05F05A11F02",       "BL391234512345123456789AB13"));
    addSpecification(new Specification("MF", 27, "F05F05A11F02",       "MF551234512345123456789AB13"));
    addSpecification(new Specification("PM", 27, "F05F05A11F02",       "PM071234512345123456789AB13"));
    addSpecification(new Specification("WF", 27, "F05F05A11F02",       "WF621234512345123456789AB13"));

    var NON_ALPHANUM = /[^a-zA-Z0-9]/g,
        EVERY_FOUR_CHARS =/(.{4})(?!$)/g;

    /**
     * Utility function to check if a variable is a String.
     *
     * @param v
     * @returns {boolean} true if the passed variable is a String, false otherwise.
     */
    function isString(v){
        return (typeof v == 'string' || v instanceof String);
    }

    /**
     * Check if an IBAN is valid.
     *
     * @param {String} iban the IBAN to validate.
     * @returns {boolean} true if the passed IBAN is valid, false otherwise
     */
    exports.isValid = function(iban){
        if (!isString(iban)){
            return false;
        }
        iban = electronicFormat(iban);
        var countryStructure = countries[iban.slice(0,2)];
        return !!countryStructure && countryStructure.isValid(iban);
    };

    /**
     * Convert an IBAN to a BBAN.
     *
     * @param iban
     * @param {String} [separator] the separator to use between the blocks of the BBAN, defaults to ' '
     * @returns {string|*}
     */
    exports.toBBAN = function(iban, separator){
        if (typeof separator == 'undefined'){
            separator = ' ';
        }
        iban = electronicFormat(iban);
        var countryStructure = countries[iban.slice(0,2)];
        if (!countryStructure) {
            throw new Error('No country with code ' + iban.slice(0,2));
        }
        return countryStructure.toBBAN(iban, separator);
    };

    /**
     * Convert the passed BBAN to an IBAN for this country specification.
     * Please note that <i>"generation of the IBAN shall be the exclusive responsibility of the bank/branch servicing the account"</i>.
     * This method implements the preferred algorithm described in http://en.wikipedia.org/wiki/International_Bank_Account_Number#Generating_IBAN_check_digits
     *
     * @param countryCode the country of the BBAN
     * @param bban the BBAN to convert to IBAN
     * @returns {string} the IBAN
     */
    exports.fromBBAN = function(countryCode, bban){
        var countryStructure = countries[countryCode];
        if (!countryStructure) {
            throw new Error('No country with code ' + countryCode);
        }
        return countryStructure.fromBBAN(electronicFormat(bban));
    };

    /**
     * Check the validity of the passed BBAN.
     *
     * @param countryCode the country of the BBAN
     * @param bban the BBAN to check the validity of
     */
    exports.isValidBBAN = function(countryCode, bban){
        if (!isString(bban)){
            return false;
        }
        var countryStructure = countries[countryCode];
        return countryStructure && countryStructure.isValidBBAN(electronicFormat(bban));
    };

    /**
     *
     * @param iban
     * @param separator
     * @returns {string}
     */
    exports.printFormat = function(iban, separator){
        if (typeof separator == 'undefined'){
            separator = ' ';
        }
        return electronicFormat(iban).replace(EVERY_FOUR_CHARS, "$1" + separator);
    };

    exports.electronicFormat = electronicFormat;
    /**
     * An object containing all the known IBAN specifications.
     */
    exports.countries = countries;

}));


/***/ }),

/***/ 127:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ countries; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ checkVAT; });

// UNUSED EXPORTS: andorra, austria, belgium, brazil, bulgaria, croatia, cyprus, czechRepublic, denmark, estonia, europe, finland, france, germany, greece, hungary, ireland, italy, latvia, lithuania, luxembourg, malta, netherlands, norway, poland, portugal, romania, russia, serbia, slovakiaRepublic, slovenia, spain, sweden, switzerland, unitedKingdom

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/andorra.js
const andorra = {
    name: 'Andorra',
    codes: ['AD', 'AND', '020'],
    calcFn: (vat) => {
        return vat.length === 8;
    },
    rules: {
        multipliers: {},
        regex: [/^(AD)([fealecdgopuFEALECDGOPU]{1}\d{6}[fealecdgopuFEALECDGOPU]{1})$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/austria.js
const austria = {
    name: 'Austria',
    codes: ['AT', 'AUT', '040'],
    calcFn: (vat) => {
        let total = 0;
        for (let i = 0; i < 7; i++) {
            const temp = Number(vat.charAt(i)) * austria.rules.multipliers.common[i];
            if (temp > 9) {
                total += Math.floor(temp / 10) + (temp % 10);
            }
            else {
                total += temp;
            }
        }
        total = 10 - ((total + 4) % 10);
        if (total === 10)
            total = 0;
        return total === Number(vat.slice(7, 8));
    },
    rules: {
        multipliers: {
            common: [1, 2, 1, 2, 1, 2, 1]
        },
        regex: [/^(AT)U(\d{8})$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/belgium.js
const belgium = {
    name: 'Belgium',
    codes: ['BE', 'BEL', '056'],
    calcFn: (vat) => {
        const newVat = vat.length === 9 ? '0' + vat : vat;
        if (Number(newVat.slice(1, 2)) === 0)
            return false;
        const check = 97 - (Number(newVat.slice(0, 8)) % 97);
        return check === Number(newVat.slice(8, 10));
    },
    rules: {
        multipliers: {},
        regex: [/^(BE)(0?\d{9})$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/brazil.js
/**
 * Generate check sums. Multiply numbers to validators and sum them to generate
 * check sums, they're used to check if numbers are valid.
 * @param numbers - Numbers used to generate checkers.
 * @param validators - Validators used to generate checkers.
 */
const generateCheckSums = (numbers, validators) => {
    const initialCheckSums = [0, 0];
    return validators.reduce(([checkerA, checkerB], validator, index) => [index === 0 ? 0 : checkerA + numbers[index - 1] * validator, checkerB + numbers[index] * validator], initialCheckSums);
};
const isRepeatedArray = (varNumbers) => varNumbers.every((varNumber) => varNumbers[0] === varNumber);
/**
 * Get remaining of 11 or `0` if lower than 2.
 * @param value - Value used remaining.
 */
const getRemaining = (value) => (value % 11 < 2 ? 0 : 11 - (value % 11));
const brazil = {
    name: 'Brazil',
    codes: ['BR', 'BRA', '076'],
    calcFn: (vat) => {
        const numbers = vat.split('').map(Number);
        if (isRepeatedArray(numbers)) {
            return false;
        }
        const validators = [6, 5, 4, 3, 2, 9, 8, 7, 6, 5, 4, 3, 2];
        const checkers = generateCheckSums(numbers, validators);
        return numbers[12] === getRemaining(checkers[0]) && numbers[13] === getRemaining(checkers[1]);
    },
    rules: {
        multipliers: {},
        regex: [/^(BR)?(\d{14}|\d{2}\.\d{3}\.\d{3}\/\d{4}-\d{2})$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/bulgaria.js
const bulgaria = {
    name: 'Bulgaria',
    codes: ['BG', 'BGR', '100'],
    calcFn: (vat) => {
        if (vat.length === 9)
            return _checkNineLengthVat(vat);
        const { multipliers } = bulgaria.rules;
        return (_isPhysicalPerson(vat, multipliers.physical) ||
            _isForeigner(vat, multipliers) ||
            _miscellaneousVAT(vat, multipliers));
    },
    rules: {
        multipliers: {
            physical: [2, 4, 8, 5, 10, 9, 7, 3, 6],
            foreigner: [21, 19, 17, 13, 11, 9, 7, 3, 1],
            miscellaneous: [4, 3, 2, 7, 6, 5, 4, 3, 2]
        },
        regex: [/^(BG)(\d{9,10})$/]
    }
};
function _increase(value, vat, from, to, incr) {
    let result = value;
    for (let i = from; i < to; i++) {
        result += Number(vat.charAt(i)) * (i + incr);
    }
    return result;
}
function _increase2(value, vat, from, to, multipliers) {
    let result = value;
    for (let i = from; i < to; i++) {
        result += Number(vat.charAt(i)) * multipliers[i];
    }
    return result;
}
function _checkNineLengthVat(vat) {
    let total;
    let temp = _increase(0, vat, 0, 8, 1);
    const expect = Number(vat.slice(8));
    total = temp % 11;
    if (total !== 10)
        return total === expect;
    temp = _increase(0, vat, 0, 8, 3);
    total = temp % 11;
    if (total === 10)
        total = 0;
    return total === expect;
}
function _isPhysicalPerson(vat, physicalMultipliers) {
    // 10 digit VAT code - see if it relates to a standard physical person
    if (/^\d\d[0-5]\d[0-3]\d\d{4}$/.test(vat)) {
        // Check month
        const month = Number(vat.slice(2, 4));
        if ((month > 0 && month < 13) || (month > 20 && month < 33) || (month > 40 && month < 53)) {
            let total = _increase2(0, vat, 0, 9, physicalMultipliers);
            // Establish check digit.
            total = total % 11;
            if (total === 10)
                total = 0;
            // Check to see if the check digit given is correct, If not, try next type of person
            if (total === Number(vat.substr(9, 1)))
                return true;
        }
    }
    return false;
}
function _isForeigner(vat, multipliers) {
    // Extract the next digit and multiply by the counter.
    const total = _increase2(0, vat, 0, 9, multipliers.foreigner);
    // Check to see if the check digit given is correct, If not, try next type of person
    return total % 10 === Number(vat.substr(9, 1));
}
function _miscellaneousVAT(vat, multipliers) {
    // Finally, if not yet identified, see if it conforms to a miscellaneous VAT number
    let total = _increase2(0, vat, 0, 9, multipliers.miscellaneous);
    // Establish check digit.
    total = 11 - (total % 11);
    if (total === 10)
        return false;
    if (total === 11)
        total = 0;
    // Check to see if the check digit given is correct, If not, we have an error with the VAT number
    const expect = Number(vat.substr(9, 1));
    return total === expect;
}

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/croatiat.js
const croatia = {
    name: 'Croatia',
    codes: ['HR', 'HRV', '191'],
    calcFn: (vat) => {
        // Checks the check digits of a Croatian VAT number using ISO 7064, MOD 11-10 for check digit.
        let product = 10;
        let sum = 0;
        for (let i = 0; i < 10; i++) {
            // Extract the next digit and implement the algorithm
            sum = (Number(vat.charAt(i)) + product) % 10;
            if (sum === 0) {
                sum = 10;
            }
            product = (2 * sum) % 11;
        }
        // Now check that we have the right check digit
        const expect = Number(vat.slice(10, 11));
        return (product + expect) % 10 === 1;
    },
    rules: {
        multipliers: {},
        regex: [/^(HR)(\d{11})$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/cyprus.js
const cyprus = {
    name: 'Cyprus',
    codes: ['CY', 'CYP', '196'],
    calcFn: (vat) => {
        // Not allowed to start with '12'
        if (Number(vat.slice(0, 2)) === 12)
            return false;
        // Extract the next digit and multiply by the counter.
        let total = extractAndMultiplyByCounter(vat, 0);
        // Establish check digit using modulus 26, and translate to char. equivalent.
        total = total % 26;
        total = String.fromCharCode(total + 65);
        // Check to see if the check digit given is correct
        const expect = vat.substr(8, 1);
        return total === expect;
    },
    rules: {
        multipliers: {},
        regex: [/^(CY)([0-59]\d{7}[A-Z])$/]
    }
};
function extractAndMultiplyByCounter(vat, total) {
    let result = total;
    for (let i = 0; i < 8; i++) {
        let temp = Number(vat.charAt(i));
        if (i % 2 === 0) {
            switch (temp) {
                case 0:
                    temp = 1;
                    break;
                case 1:
                    temp = 0;
                    break;
                case 2:
                    temp = 5;
                    break;
                case 3:
                    temp = 7;
                    break;
                case 4:
                    temp = 9;
                    break;
                default:
                    temp = temp * 2 + 3;
            }
        }
        result += temp;
    }
    return result;
}

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/czechRepublic.js
const czechRepublic = {
    name: 'Czech Republic',
    codes: ['CZ', 'CZE', '203'],
    calcFn: (vat) => {
        const { rules } = czechRepublic;
        const { multipliers, additional, lookup } = rules;
        if (!additional)
            return false;
        return (isLegalEntities(vat, multipliers.common, additional) ||
            isIndividualType2(vat, multipliers.common, additional, lookup) ||
            isIndividualType3(vat, additional) ||
            isIndividualType1(vat, additional));
    },
    rules: {
        multipliers: {
            common: [8, 7, 6, 5, 4, 3, 2]
        },
        lookup: [8, 7, 6, 5, 4, 3, 2, 1, 0, 9, 8],
        regex: [/^(CZ)(\d{8,10})(\d{3})?$/],
        additional: [/^\d{8}$/, /^[0-5][0-9][0|1|5|6]\d[0-3]\d\d{3}$/, /^6\d{8}$/, /^\d{2}[0-3|5-8]\d[0-3]\d\d{4}$/]
    }
};
function isLegalEntities(vat, multipliers, additional) {
    let total = 0;
    if (additional[0].test(vat)) {
        // Extract the next digit and multiply by the counter.
        for (let i = 0; i < 7; i++) {
            total += Number(vat.charAt(i)) * multipliers[i];
        }
        // Establish check digit.
        total = 11 - (total % 11);
        if (total === 10)
            total = 0;
        if (total === 11)
            total = 1;
        // Compare it with the last character of the VAT number. If it's the same, then it's valid.
        const expect = Number(vat.slice(7, 8));
        return total === expect;
    }
    return false;
}
function isIndividualType1(vat, additional) {
    if (additional[1].test(vat)) {
        return Number(vat.slice(0, 2)) <= 62;
    }
    return false;
}
function isIndividualType2(vat, multipliers, additional, lookup) {
    let total = 0;
    if (additional[2].test(vat)) {
        // Extract the next digit and multiply by the counter.
        for (let j = 0; j < 7; j++) {
            total += Number(vat.charAt(j + 1)) * multipliers[j];
        }
        // Establish check digit.
        let a;
        if (total % 11 === 0) {
            a = total + 11;
        }
        else {
            a = Math.ceil(total / 11) * 11;
        }
        const pointer = a - total - 1;
        // Convert calculated check digit according to a lookup table
        const expect = Number(vat.slice(8, 9));
        if (!lookup)
            return false;
        return lookup[pointer] === expect;
    }
    return false;
}
function isIndividualType3(vat, additional) {
    if (additional[3].test(vat)) {
        const temp = Number(vat.slice(0, 2)) +
            Number(vat.slice(2, 4)) +
            Number(vat.slice(4, 6)) +
            Number(vat.slice(6, 8)) +
            Number(vat.slice(8));
        const expect = Number(vat) % 11 === 0;
        return !!(temp % 11 === 0 && expect);
    }
    return false;
}

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/denmark.js
const denmark = {
    name: 'Denmark',
    codes: ['DK', 'DNK', '208'],
    calcFn: (vat) => {
        let total = 0;
        for (let i = 0; i < 8; i++) {
            total += Number(vat.charAt(i)) * denmark.rules.multipliers.common[i];
        }
        return total % 11 === 0;
    },
    rules: {
        multipliers: {
            common: [2, 7, 6, 5, 4, 3, 2, 1]
        },
        regex: [/^(DK)(\d{8})$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/estonia.js
const estonia = {
    name: 'Estonia',
    codes: ['EE', 'EST', '233'],
    calcFn: (vat) => {
        let total = 0;
        let expect;
        // Extract the next digit and multiply by the counter.
        for (let i = 0; i < 8; i++) {
            total += Number(vat.charAt(i)) * estonia.rules.multipliers.common[i];
        }
        // Establish check digits using modulus 10.
        total = 10 - (total % 10);
        if (total === 10)
            total = 0;
        // Compare it with the last character of the VAT number. If it's the same, then it's valid.
        expect = Number(vat.slice(8, 9));
        return total === expect;
    },
    rules: {
        multipliers: {
            common: [3, 7, 1, 3, 7, 1, 3, 7]
        },
        regex: [/^(EE)(10\d{7})$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/europe.js
const europe = {
    name: 'Europe',
    codes: ['EU', 'EUR', '000'],
    calcFn: () => {
        // We know little about EU numbers apart from the fact that the first 3 digits represent the
        // country, and that there are nine digits in total.
        return true;
    },
    rules: {
        multipliers: {},
        regex: [/^(EU)(\d{9})$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/finland.js
const finland = {
    name: 'Finland',
    codes: ['FI', 'FIN', '246'],
    calcFn: (vat) => {
        let total = 0;
        // Extract the next digit and multiply by the counter.
        for (let i = 0; i < 7; i++)
            total += Number(vat.charAt(i)) * finland.rules.multipliers.common[i];
        // Establish check digit.
        total = 11 - (total % 11);
        if (total > 9) {
            total = 0;
        }
        // Compare it with the last character of the VAT number. If it's the same, then it's valid.
        const expect = Number(vat.slice(7, 8));
        return total === expect;
    },
    rules: {
        multipliers: {
            common: [7, 9, 10, 5, 8, 4, 2]
        },
        regex: [/^(FI)(\d{8})$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/france.js
const france = {
    name: 'France',
    codes: ['FR', 'FRA', '250'],
    calcFn: (vat) => {
        let total;
        // Checks the check digits of a French VAT number.
        if (!/^\d{11}$/.test(vat))
            return true;
        // Extract the last nine digits as an integer.
        total = Number(vat.substring(2));
        // Establish check digit.
        total = (total * 100 + 12) % 97;
        // Compare it with the last character of the VAT number. If it's the same, then it's valid.
        const expect = Number(vat.slice(0, 2));
        return total === expect;
    },
    rules: {
        multipliers: {},
        regex: [/^(FR)(\d{11})$/, /^(FR)([A-HJ-NP-Z]\d{10})$/, /^(FR)(\d[A-HJ-NP-Z]\d{9})$/, /^(FR)([A-HJ-NP-Z]{2}\d{9})$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/germany.js
const germany = {
    name: 'Germany',
    codes: ['DE', 'DEU', '276'],
    calcFn: (vat) => {
        // Checks the check digits of a German VAT number.
        let product = 10;
        let sum = 0;
        let checkDigit = 0;
        let expect;
        for (let i = 0; i < 8; i++) {
            // Extract the next digit and implement peculiar algorithm!.
            sum = (Number(vat.charAt(i)) + product) % 10;
            if (sum === 0) {
                sum = 10;
            }
            product = (2 * sum) % 11;
        }
        // Establish check digit.
        if (11 - product === 10) {
            checkDigit = 0;
        }
        else {
            checkDigit = 11 - product;
        }
        // Compare it with the last two characters of the VAT number. If the same, then it is a valid
        // check digit.
        expect = Number(vat.slice(8, 9));
        return checkDigit === expect;
    },
    rules: {
        multipliers: {},
        regex: [/^(DE)([1-9]\d{8})$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/greece.js
const greece = {
    name: 'Greece',
    codes: ['GR', 'GRC', '300'],
    calcFn: (vat) => {
        let total = 0;
        // eight character numbers should be prefixed with an 0.
        const newVat = vat.length === 8 ? '0' + vat : vat;
        // Extract the next digit and multiply by the counter.
        for (let i = 0; i < 8; i++) {
            total += Number(newVat.charAt(i)) * greece.rules.multipliers.common[i];
        }
        // Establish check digit.
        total = total % 11;
        total = total > 9 ? 0 : total;
        // Compare it with the last character of the VAT number. If it's the same, then it's valid.
        const expect = Number(newVat.slice(8, 9));
        return total === expect;
    },
    rules: {
        multipliers: {
            common: [256, 128, 64, 32, 16, 8, 4, 2]
        },
        regex: [/^(EL)(\d{9})$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/hungary.js
const hungary = {
    name: 'Hungary',
    codes: ['HU', 'HUN', '348'],
    calcFn: (vat) => {
        let total = 0;
        // Extract the next digit and multiply by the counter.
        for (let i = 0; i < 7; i++) {
            total += Number(vat.charAt(i)) * hungary.rules.multipliers.common[i];
        }
        // Establish check digit.
        total = 10 - (total % 10);
        if (total === 10)
            total = 0;
        // Compare it with the last character of the VAT number. If it's the same, then it's valid.
        const expect = Number(vat.slice(7, 8));
        return total === expect;
    },
    rules: {
        multipliers: {
            common: [9, 7, 3, 1, 9, 7, 3]
        },
        regex: [/^(HU)(\d{8})$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/ireland.js
const ireland = {
    name: 'Ireland',
    codes: ['IE', 'IRL', '372'],
    calcFn: (vat) => {
        const { typeFormats, multipliers } = ireland.rules;
        if (!typeFormats || !typeFormats.first)
            return false;
        let total = 0;
        let newVat = vat;
        // If the code is type 1 format, we need to convert it to the new before performing the validation.
        if (typeFormats.first.test(vat)) {
            newVat = '0' + vat.substring(2, 7) + vat.substring(0, 1) + vat.substring(7, 8);
        }
        // Extract the next digit and multiply by the counter.
        for (let i = 0; i < 7; i++) {
            total += Number(newVat.charAt(i)) * multipliers.common[i];
        }
        // If the number is type 3 then we need to include the trailing A or H in the calculation
        if (typeFormats.third.test(newVat)) {
            // Add in a multiplier for the character A (1*9=9) or H (8*9=72)
            total += newVat.charAt(8) === 'H' ? 72 : 9;
        }
        // Establish check digit using modulus 23, and translate to char. equivalent.
        total = total % 23;
        total = total === 0 ? 'W' : String.fromCharCode(total + 64);
        // Compare it with the eighth character of the VAT number. If it's the same, then it's valid.
        const expect = newVat.slice(7, 8);
        return total === expect;
    },
    rules: {
        multipliers: {
            common: [8, 7, 6, 5, 4, 3, 2]
        },
        typeFormats: {
            first: /^\d[A-Z*+]/,
            third: /^\d{7}[A-Z][AH]$/
        },
        regex: [/^(IE)(\d{7}[A-W])$/, /^(IE)([7-9][A-Z*+)]\d{5}[A-W])$/, /^(IE)(\d{7}[A-W][AH])$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/italy.js
const italy = {
    name: 'Italy',
    codes: ['IT', 'ITA', '380'],
    calcFn: (vat) => {
        let total = 0;
        let temp;
        // The last three digits are the issuing office, and cannot exceed more 201, unless 999 or 888
        if (Number(vat.slice(0, 7)) === 0) {
            return false;
        }
        temp = Number(vat.slice(7, 10));
        if (temp < 1 || (temp > 201 && temp !== 999 && temp !== 888)) {
            return false;
        }
        // Extract the next digit and multiply by the appropriate
        for (let i = 0; i < 10; i++) {
            temp = Number(vat.charAt(i)) * italy.rules.multipliers.common[i];
            if (temp > 9)
                total += Math.floor(temp / 10) + (temp % 10);
            else
                total += temp;
        }
        // Establish check digit.
        total = 10 - (total % 10);
        if (total > 9) {
            total = 0;
        }
        // Compare it with the last character of the VAT number. If it's the same, then it's valid.
        const expect = Number(vat.slice(10, 11));
        return total === expect;
    },
    rules: {
        multipliers: {
            common: [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]
        },
        regex: [/^(IT)(\d{11})$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/latvia.js
const latvia = {
    name: 'Latvia',
    codes: ['LV', 'LVA', '428'],
    calcFn: (vat) => {
        let total = 0;
        // Differentiate between legal entities and natural bodies. For the latter we simply check that
        // the first six digits correspond to valid DDMMYY dates.
        if (/^[0-3]/.test(vat)) {
            return Boolean(/^[0-3][0-9][0-1][0-9]/.test(vat));
        }
        else {
            // Extract the next digit and multiply by the counter.
            for (let i = 0; i < 10; i++) {
                total += Number(vat.charAt(i)) * latvia.rules.multipliers.common[i];
            }
            // Establish check digits by getting modulus 11.
            if (total % 11 === 4 && Number(vat[0]) === 9)
                total = total - 45;
            if (total % 11 === 4) {
                total = 4 - (total % 11);
            }
            else if (total % 11 > 4) {
                total = 14 - (total % 11);
            }
            else if (total % 11 < 4) {
                total = 3 - (total % 11);
            }
            // Compare it with the last character of the VAT number. If it's the same, then it's valid.
            const expect = Number(vat.slice(10, 11));
            return total === expect;
        }
    },
    rules: {
        multipliers: {
            common: [9, 1, 4, 8, 3, 10, 2, 5, 7, 6]
        },
        regex: [/^(LV)(\d{11})$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/lithuania.js
const lithuania = {
    name: 'Lithuania',
    codes: ['LT', 'LTU', '440'],
    calcFn: (vat) => {
        return _check9DigitVat(vat, lithuania.rules) || _check12DigitVat(vat, lithuania.rules);
    },
    rules: {
        multipliers: {
            short: [3, 4, 5, 6, 7, 8, 9, 1],
            med: [1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2],
            alt: [3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4]
        },
        check: /^\d{10}1/,
        regex: [/^(LT)(\d{9}|\d{12})$/]
    }
};
function _extractDigit(vat, multiplierList, key) {
    return Number(vat.charAt(key)) * multiplierList[key];
}
function _doubleCheckCalculation(vat, total, rules) {
    let result = total;
    if (result % 11 === 10) {
        result = 0;
        for (let i = 0; i < 8; i++) {
            result += _extractDigit(vat, rules.multipliers.short, i);
        }
    }
    return result;
}
function extractDigit(vat, total) {
    let result = total;
    for (let i = 0; i < 8; i++) {
        result += Number(vat.charAt(i)) * (i + 1);
    }
    return result;
}
function checkDigit(total) {
    let result = total % 11;
    if (result === 10) {
        result = 0;
    }
    return result;
}
function _check9DigitVat(vat, rules) {
    // 9 character VAT numbers are for legal persons
    let total = 0;
    if (vat.length === 9) {
        // 8th character must be one
        if (!/^\d{7}1/.test(vat))
            return false;
        // Extract the next digit and multiply by the counter+1.
        total = extractDigit(vat, total);
        // Can have a double check digit calculation!
        total = _doubleCheckCalculation(vat, total, rules);
        // Establish check digit.
        total = checkDigit(total);
        // Compare it with the last character of the VAT number. If it's the same, then it's valid.
        const expect = Number(vat.slice(8, 9));
        return total === expect;
    }
    return false;
}
function extractDigit12(vat, total, rules) {
    let result = total;
    for (let k = 0; k < 11; k++) {
        result += _extractDigit(vat, rules.multipliers.med, k);
    }
    return result;
}
function _doubleCheckCalculation12(vat, total, rules) {
    let result = total;
    if (total % 11 === 10) {
        result = 0;
        for (let l = 0; l < 11; l++) {
            result += _extractDigit(vat, rules.multipliers.alt, l);
        }
    }
    return result;
}
function _check12DigitVat(vat, rules) {
    let total = 0;
    // 12 character VAT numbers are for temporarily registered taxpayers
    if (vat.length === 12) {
        if (!rules.check)
            return false;
        // 11th character must be one
        if (!rules.check.test(vat))
            return false;
        // Extract the next digit and multiply by the counter+1.
        total = extractDigit12(vat, total, rules);
        // Can have a double check digit calculation!
        total = _doubleCheckCalculation12(vat, total, rules);
        // Establish check digit.
        total = checkDigit(total);
        // Compare it with the last character of the VAT number. If it's the same, then it's valid.
        const expect = Number(vat.slice(11, 12));
        return total === expect;
    }
    return false;
}

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/luxembourg.js
const luxembourg = {
    name: 'Luxembourg',
    codes: ['LU', 'LUX', '442'],
    calcFn: (vat) => {
        const expect = Number(vat.slice(6, 8));
        const checkDigit = Number(vat.slice(0, 6)) % 89;
        // Checks the check digits of a Luxembourg VAT number.
        return checkDigit === expect;
    },
    rules: {
        multipliers: {},
        regex: [/^(LU)(\d{8})$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/malta.js
const malta = {
    name: 'Malta',
    codes: ['MT', 'MLT', '470'],
    calcFn: (vat) => {
        let total = 0;
        // Extract the next digit and multiply by the counter.
        for (let i = 0; i < 6; i++) {
            total += Number(vat.charAt(i)) * malta.rules.multipliers.common[i];
        }
        // Establish check digits by getting modulus 37.
        total = 37 - (total % 37);
        // Compare it with the last character of the VAT number. If it's the same, then it's valid.
        const expect = Number(vat.slice(6, 8));
        return total === expect;
    },
    rules: {
        multipliers: {
            common: [3, 4, 6, 7, 8, 9]
        },
        regex: [/^(MT)([1-9]\d{7})$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/netherlands.js
const netherlands = {
    name: 'Netherlands',
    codes: ['NL', 'NLD', '528'],
    calcFn: (input) => {
        const vat = input.replace(/[\ \-\_]/g, '').toUpperCase();
        const { additional, multipliers } = netherlands.rules;
        if (!additional)
            return false;
        const match = vat.match(additional[0]);
        if (!match || !match[1])
            return false;
        const numb = match[1];
        const characterValues = `NL${vat}`.split('').map(getCharValue);
        let total = 0;
        // Extract the next digit and multiply by the counter.
        for (let i = 0; i < 8; i++) {
            total += Number(numb.charAt(i)) * multipliers.common[i];
        }
        // Establish check digits by getting modulus 11.
        total = total % 11;
        if (total > 9) {
            total = 0;
        }
        // Compare it with the last character of the VAT number. If it's the same, then it's valid.
        const expect = Number(numb.slice(8, 9));
        // is either 11 proof or 97 mod proof.
        return total === expect || isNinetySevenMod(characterValues.join(''));
    },
    rules: {
        multipliers: {
            common: [9, 8, 7, 6, 5, 4, 3, 2]
        },
        regex: [/^(NL)(\d{9}B\d{2})$/],
        additional: [/^(\d{9})B\d{2}$/]
    }
};
function getCharValue(char) {
    // if one of these set values
    if (char === '+')
        return 36;
    if (char === '*')
        return 37;
    // if A...Z return code VAL -55
    const code = char.charCodeAt(0) - 55;
    if (code > 9 && code < 91)
        return code;
    return parseInt(char, 10);
}
function isNinetySevenMod(value) {
    const remainder = mod(value, 97);
    return remainder === 1;
}
// custom module function, to check module on values above Number limit
function mod(value, divisor) {
    // Initialize result
    let res = 0;
    for (const char of value.split('')) {
        res = (res * 10 + +char) % divisor;
    }
    return res;
}

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/norway.js
const norway = {
    name: 'Norway',
    codes: ['NO', 'NOR', '578'],
    calcFn: (vat) => {
        let total = 0;
        // See http://www.brreg.no/english/coordination/number.html
        // Extract the next digit and multiply by the counter.
        for (let i = 0; i < 8; i++) {
            total += Number(vat.charAt(i)) * norway.rules.multipliers.common[i];
        }
        // Establish check digits by getting modulus 11. Check digits > 9 are invalid
        total = 11 - (total % 11);
        if (total === 11) {
            total = 0;
        }
        if (total < 10) {
            // Compare it with the last character of the VAT number. If it's the same, then it's valid.
            const expect = Number(vat.slice(8, 9));
            return total === expect;
        }
        return false;
    },
    rules: {
        multipliers: {
            common: [3, 2, 7, 6, 5, 4, 3, 2]
        },
        regex: [/^(NO)(\d{9})(MVA)?$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/poland.js
const poland = {
    name: 'Poland',
    codes: ['PL', 'POL', '616'],
    calcFn: (vat) => {
        let total = 0;
        // Extract the next digit and multiply by the counter.
        for (let i = 0; i < 9; i++) {
            total += Number(vat.charAt(i)) * poland.rules.multipliers.common[i];
        }
        // Establish check digits subtracting modulus 11 from 11.
        total = total % 11;
        if (total > 9) {
            total = 0;
        }
        // Compare it with the last character of the VAT number. If it's the same, then it's valid.
        const expect = Number(vat.slice(9, 10));
        return total === expect;
    },
    rules: {
        multipliers: {
            common: [6, 5, 7, 2, 3, 4, 5, 6, 7]
        },
        regex: [/^(PL)(\d{10})$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/portugal.js
const portugal = {
    name: 'Portugal',
    codes: ['PT', 'PRT', '620'],
    calcFn: (vat) => {
        let total = 0;
        // Extract the next digit and multiply by the counter.
        for (let i = 0; i < 8; i++) {
            total += Number(vat.charAt(i)) * portugal.rules.multipliers.common[i];
        }
        // Establish check digits subtracting modulus 11 from 11.
        total = 11 - (total % 11);
        if (total > 9) {
            total = 0;
        }
        // Compare it with the last character of the VAT number. If it's the same, then it's valid.
        const expect = Number(vat.slice(8, 9));
        return total === expect;
    },
    rules: {
        multipliers: {
            common: [9, 8, 7, 6, 5, 4, 3, 2]
        },
        regex: [/^(PT)(\d{9})$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/romania.js
const romania = {
    name: 'Romania',
    codes: ['RO', 'ROU', '642'],
    calcFn: (vat) => {
        let total = 0;
        // Extract the next digit and multiply by the counter.
        const vatLength = vat.length;
        const multipliers = romania.rules.multipliers.common.slice(10 - vatLength);
        for (let i = 0; i < vat.length - 1; i++) {
            total += Number(vat.charAt(i)) * multipliers[i];
        }
        // Establish check digits by getting modulus 11.
        total = (10 * total) % 11;
        if (total === 10)
            total = 0;
        // Compare it with the last character of the VAT number. If it's the same, then it's valid.
        const expect = Number(vat.slice(vat.length - 1, vat.length));
        return total === expect;
    },
    rules: {
        multipliers: {
            common: [7, 5, 3, 2, 1, 7, 5, 3, 2]
        },
        regex: [/^(RO)([1-9]\d{1,9})$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/russia.js
const russia = {
    name: 'Russian Federation',
    codes: ['RU', 'RUS', '643'],
    calcFn: (vat) => {
        // See http://russianpartner.biz/test_inn.html for algorithm
        return _check10DigitINN(vat, russia.rules) || _check12DigitINN(vat, russia.rules);
    },
    rules: {
        multipliers: {
            m_1: [2, 4, 10, 3, 5, 9, 4, 6, 8, 0],
            m_2: [7, 2, 4, 10, 3, 5, 9, 4, 6, 8, 0],
            m_3: [3, 7, 2, 4, 10, 3, 5, 9, 4, 6, 8, 0]
        },
        regex: [/^(RU)(\d{10}|\d{12})$/]
    }
};
function _check10DigitINN(vat, rules) {
    let total = 0;
    if (vat.length === 10) {
        for (let i = 0; i < 10; i++) {
            total += Number(vat.charAt(i)) * rules.multipliers.m_1[i];
        }
        total = total % 11;
        if (total > 9) {
            total = total % 10;
        }
        // Compare it with the last character of the VAT number. If it is the same, then it's valid
        const expect = Number(vat.slice(9, 10));
        return total === expect;
    }
    return false;
}
function _check12DigitINN(vat, rules) {
    let total1 = 0;
    let total2 = 0;
    if (vat.length === 12) {
        for (let j = 0; j < 11; j++) {
            total1 += Number(vat.charAt(j)) * rules.multipliers.m_2[j];
        }
        total1 = total1 % 11;
        if (total1 > 9) {
            total1 = total1 % 10;
        }
        for (let k = 0; k < 11; k++) {
            total2 += Number(vat.charAt(k)) * rules.multipliers.m_3[k];
        }
        total2 = total2 % 11;
        if (total2 > 9) {
            total2 = total2 % 10;
        }
        // Compare the first check with the 11th character and the second check with the 12th and last
        // character of the VAT number. If they're both the same, then it's valid
        const expect = total1 === Number(vat.slice(10, 11));
        const expect2 = total2 === Number(vat.slice(11, 12));
        return expect && expect2;
    }
    return false;
}

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/serbia.js
const serbia = {
    name: 'Serbia',
    codes: ['RS', 'SRB', '688'],
    calcFn: (vat) => {
        // Checks the check digits of a Serbian VAT number using ISO 7064, MOD 11-10 for check digit.
        let product = 10;
        let sum = 0;
        for (let i = 0; i < 8; i++) {
            // Extract the next digit and implement the algorithm
            sum = (Number(vat.charAt(i)) + product) % 10;
            if (sum === 0) {
                sum = 10;
            }
            product = (2 * sum) % 11;
        }
        // Now check that we have the right check digit
        const expect = 1;
        const checkDigit = (product + Number(vat.slice(8, 9))) % 10;
        return checkDigit === expect;
    },
    rules: {
        multipliers: {},
        regex: [/^(RS)(\d{9})$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/slovakiaRepublic.js
const slovakiaRepublic = {
    name: 'Slovakia Republic',
    codes: ['SK', 'SVK', '703'],
    calcFn: (vat) => {
        const expect = 0;
        const checkDigit = Number(vat) % 11;
        return checkDigit === expect;
    },
    rules: {
        multipliers: {},
        regex: [/^(SK)([1-9]\d[2346-9]\d{7})$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/slovenia.js
const slovenia = {
    name: 'Slovenia',
    codes: ['SI', 'SVN', '705'],
    calcFn: (vat) => {
        let total = 0;
        // Extract the next digit and multiply by the counter.
        for (let i = 0; i < 7; i++) {
            total += Number(vat.charAt(i)) * slovenia.rules.multipliers.common[i];
        }
        // Establish check digits using modulus 11
        total = 11 - (total % 11);
        if (total === 10) {
            total = 0;
        }
        // Compare the number with the last character of the VAT number. If it is the
        // same, then it's a valid check digit.
        const expect = Number(vat.slice(7, 8));
        return !!(total !== 11 && total === expect);
    },
    rules: {
        multipliers: {
            common: [8, 7, 6, 5, 4, 3, 2]
        },
        regex: [/^(SI)([1-9]\d{7})$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/spain.js
const spain = {
    name: 'Spain',
    codes: ['ES', 'ESP', '724'],
    calcFn: (vat) => {
        const { additional, multipliers } = spain.rules;
        if (!additional)
            return false;
        // National juridical entities
        if (additional[0].test(vat))
            return isNationalJuridicalEntities(vat, multipliers.common);
        // Juridical entities other than national ones
        if (additional[1].test(vat))
            return isNonNationalJuridical(vat, multipliers.common);
        // Personal number (NIF) (starting with numeric of Y or Z)
        if (additional[2].test(vat))
            return isPersonalYtoZ(vat);
        // Personal number (NIF) (starting with K, L, M, or X)
        if (additional[3].test(vat))
            return isPersonalKtoX(vat);
        return false;
    },
    rules: {
        multipliers: {
            common: [2, 1, 2, 1, 2, 1, 2]
        },
        regex: [
            /^(ES)([A-Z]\d{8})$/,
            /^(ES)([A-HN-SW]\d{7}[A-J])$/,
            /^(ES)([0-9YZ]\d{7}[A-Z])$/,
            /^(ES)([KLMX]\d{7}[A-Z])$/
        ],
        additional: [/^[A-H|J|U|V]\d{8}$/, /^[A-H|N-S|W]\d{7}[A-J]$/, /^[0-9|Y|Z]\d{7}[A-Z]$/, /^[K|L|M|X]\d{7}[A-Z]$/]
    }
};
function extractDigitAndMultiplyByCounter(vat, multipliers, total) {
    let temp;
    let result = total;
    for (let i = 0; i < 7; i++) {
        temp = Number(vat.charAt(i + 1)) * multipliers[i];
        if (temp > 9) {
            result += Math.floor(temp / 10) + (temp % 10);
        }
        else {
            result += temp;
        }
    }
    return result;
}
function isNationalJuridicalEntities(vat, multipliers) {
    let total = extractDigitAndMultiplyByCounter(vat, multipliers, 0);
    // Now calculate the check digit itself.
    total = 10 - (total % 10);
    if (total === 10) {
        total = 0;
    }
    // Compare it with the last character of the VAT number. If it's the same, then it's valid.
    const expect = Number(vat.slice(8, 9));
    return total === expect;
}
function isNonNationalJuridical(vat, multipliers) {
    let total = extractDigitAndMultiplyByCounter(vat, multipliers, 0);
    // Now calculate the check digit itself.
    total = 10 - (total % 10);
    const totalStr = String.fromCharCode(total + 64);
    // Compare it with the last character of the VAT number. If it's the same, then it's valid.
    const expect = vat.slice(8, 9);
    return totalStr === expect;
}
function isPersonalYtoZ(vat) {
    let tempNumber = vat;
    if (tempNumber.substring(0, 1) === 'Y')
        tempNumber = tempNumber.replace(/Y/, '1');
    if (tempNumber.substring(0, 1) === 'Z')
        tempNumber = tempNumber.replace(/Z/, '2');
    const expect = 'TRWAGMYFPDXBNJZSQVHLCKE'.charAt(+tempNumber.substring(0, 8) % 23);
    return tempNumber.charAt(8) === expect;
}
function isPersonalKtoX(vat) {
    const expect = 'TRWAGMYFPDXBNJZSQVHLCKE'.charAt(Number(vat.substring(1, 8)) % 23);
    return vat.charAt(8) === expect;
}

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/sweden.js
const sweden = {
    name: 'Sweden',
    codes: ['SE', 'SWE', '752'],
    calcFn: (vat) => {
        let expect;
        // Calculate R where R = R1 + R3 + R5 + R7 + R9, and Ri = INT(Ci/5) + (Ci*2) modulo 10
        let R = 0;
        for (let i = 0; i < 9; i = i + 2) {
            const digit = Number(vat.charAt(i));
            R += Math.floor(digit / 5) + ((digit * 2) % 10);
        }
        // Calculate S where S = C2 + C4 + C6 + C8
        let S = 0;
        for (let j = 1; j < 9; j = j + 2) {
            S += Number(vat.charAt(j));
        }
        const checkDigit = (10 - ((R + S) % 10)) % 10;
        // Compare it with the last character of the VAT number. If it's the same, then it's valid.
        expect = Number(vat.slice(9, 10));
        return checkDigit === expect;
    },
    rules: {
        multipliers: {},
        regex: [/^(SE)(\d{10}01)$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/switzerland.js
const switzerland = {
    name: 'Switzerland',
    codes: ['CH', 'CHE', '756'],
    calcFn: (vat) => {
        let total = 0;
        for (let i = 0; i < 8; i++) {
            total += Number(vat.charAt(i)) * switzerland.rules.multipliers.common[i];
        }
        // Establish check digit.s
        total = 11 - (total % 11);
        if (total === 10)
            return false;
        if (total === 11)
            total = 0;
        // Check to see if the check digit given is correct, If not, we have an error with the VAT number
        const expect = Number(vat.substr(8, 1));
        return total === expect;
    },
    rules: {
        multipliers: {
            common: [5, 4, 3, 2, 7, 6, 5, 4]
        },
        regex: [/^(CHE)(\d{9})(MWST|TVA|IVA)?$/]
    }
};

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/unitedKingdom.js
const unitedKingdom = {
    name: 'United Kingdom',
    codes: ['GB', 'GBR', '826'],
    calcFn: (vat) => {
        // Government departments
        if (vat.substr(0, 2) === 'GD')
            return isGovernmentDepartment(vat);
        // Health authorities
        if (vat.substr(0, 2) === 'HA')
            return isHealthAuthorities(vat);
        // Standard and commercial numbers
        return isStandardOrCommercialNumber(vat, unitedKingdom.rules.multipliers.common);
    },
    rules: {
        multipliers: {
            common: [8, 7, 6, 5, 4, 3, 2]
        },
        regex: [/^(GB)?(\d{9})$/, /^(GB)?(\d{12})$/, /^(GB)?(GD\d{3})$/, /^(GB)?(HA\d{3})$/]
    }
};
function isGovernmentDepartment(vat) {
    const expect = 500;
    return Number(vat.substr(2, 3)) < expect;
}
function isHealthAuthorities(vat) {
    const expect = 499;
    return Number(vat.substr(2, 3)) > expect;
}
function isStandardOrCommercialNumber(vat, multipliers) {
    let total = 0;
    // 0 VAT numbers disallowed!
    if (Number(vat.slice(0)) === 0)
        return false;
    // Check range is OK for modulus 97 calculation
    const no = Number(vat.slice(0, 7));
    // Extract the next digit and multiply by the counter.
    for (let i = 0; i < 7; i++) {
        total += Number(vat.charAt(i)) * multipliers[i];
    }
    // Old numbers use a simple 97 modulus, but new numbers use an adaptation of that (less 55). Our
    // VAT number could use either system, so we check it against both.
    // Establish check digits by subtracting 97 from total until negative.
    let checkDigit = total;
    while (checkDigit > 0) {
        checkDigit = checkDigit - 97;
    }
    // Get the absolute value and compare it with the last two characters of the VAT number. If the
    // same, then it is a valid traditional check digit. However, even then the number must fit within
    // certain specified ranges.
    checkDigit = Math.abs(checkDigit);
    if (checkDigit === Number(vat.slice(7, 9)) &&
        no < 9990001 &&
        (no < 100000 || no > 999999) &&
        (no < 9490001 || no > 9700000)) {
        return true;
    }
    // Now try the new method by subtracting 55 from the check digit if we can - else add 42
    if (checkDigit >= 55) {
        checkDigit = checkDigit - 55;
    }
    else {
        checkDigit = checkDigit + 42;
    }
    const expect = Number(vat.slice(7, 9));
    return Boolean(checkDigit === expect && no > 1000000);
}

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/countries/index.js




































// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/lib/jsvat.js

function makeResult(vat, isValid, country) {
    return {
        value: vat || undefined,
        isValid: Boolean(isValid),
        isValidFormat: country ? isVatValidToRegexp(vat, country.rules.regex).isValid : false,
        isSupportedCountry: Boolean(country),
        country: !country
            ? undefined
            : {
                name: country.name,
                isoCode: {
                    short: country.codes[0],
                    long: country.codes[1],
                    numeric: country.codes[2]
                }
            }
    };
}
function removeExtraChars(vat = '') {
    return vat
        .toString()
        .toUpperCase()
        .replace(/(\s|-|\.|\/)+/g, '');
}
function getCountryCodes(country) {
    return [...country.codes, country.name === 'Greece' ? 'EL' : undefined].filter(Boolean);
}
const countriesVATDoesNotStartWithCountryCode = [brazil.name];
function isVATStartWithCountryCode(countryName) {
    return !countriesVATDoesNotStartWithCountryCode.includes(countryName);
}
function isVATStartWithNumber(vat) {
    return !!vat.match(/^\d{2}/);
}
function getCountry(vat, countriesList) {
    for (const country of countriesList) {
        if (startsWithCode(vat, country) || (!isVATStartWithCountryCode(country.name) && isVATStartWithNumber(vat))) {
            return { ...country };
        }
    }
    return undefined;
}
function startsWithCode(vat, country) {
    const countryCodes = getCountryCodes(country);
    return countryCodes.filter((code) => vat.startsWith(code)).length > 0;
}
function isVatValidToRegexp(vat, regexArr) {
    for (const regex of regexArr) {
        const isValid = regex.test(vat);
        if (isValid)
            return { isValid: true, regex: regex };
    }
    return { isValid: false, regex: undefined };
}
function isVatValid(vat, country) {
    const regexpValidRes = isVatValidToRegexp(vat, country.rules.regex);
    if (!regexpValidRes.isValid || !regexpValidRes.regex)
        return false;
    const regexResult = regexpValidRes.regex.exec(vat);
    if (!regexResult)
        return false;
    return country.calcFn(regexResult[2]);
}
function checkVAT(vat, countriesList = []) {
    if (!vat)
        return makeResult(vat, false);
    const cleanVAT = removeExtraChars(vat);
    const country = getCountry(cleanVAT, countriesList);
    const isValid = country ? isVatValid(cleanVAT, country) : false;
    return makeResult(cleanVAT, isValid, country);
}

// CONCATENATED MODULE: ./node_modules/jsvat/lib/es6/index.js

const countries = [
    andorra,
    austria,
    belgium,
    brazil,
    bulgaria,
    croatia,
    cyprus,
    czechRepublic,
    denmark,
    estonia,
    europe,
    finland,
    france,
    germany,
    greece,
    hungary,
    ireland,
    italy,
    latvia,
    lithuania,
    luxembourg,
    malta,
    netherlands,
    norway,
    poland,
    portugal,
    romania,
    russia,
    serbia,
    slovakiaRepublic,
    slovenia,
    spain,
    sweden,
    switzerland,
    unitedKingdom
];




/***/ })

}]);