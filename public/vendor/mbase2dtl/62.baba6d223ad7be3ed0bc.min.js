(window["webpackJsonpmbase2modules"] = window["webpackJsonpmbase2modules"] || []).push([[62],{

/***/ 53:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//https://dev.to/trezy/loading-images-with-web-workers-49ap
const MediaScroller = function(op) {

    this.mediaRoot = op.mediaRoot;
    this.fetchFun = op.fetch;
    this.init();
    this.loadingStep = 1000;  //put an observer to every 50th element

    this.op = op;

    this.scope = op.scope === undefined ? '/processed' : op.scope;

    this.onMediaSelected = op.onMediaSelected;
    this.onMediaSelectionChanged = op.onMediaSelectionChanged;

    const $el = $('<div class="image-container"/>');
    this.$el = () => $el;

    /*
    let observerOptions = {
        root: $el[0],
        rootMargin: '0px',
        threshold: 1.0
    };
      
    this.observer = new IntersectionObserver((entries, observer)=>{
        if (entries[0].isIntersecting === true) {
            observer.unobserve(entries[0].target);
            this._fetch();
        }
    }, observerOptions);
*/
    this._fetch();
}

MediaScroller.prototype._fetch = function () {
    if (this.fetchFun) {
    
        this.fetchFun(this.offset, this.scope).then(res => {
            this.appendImages(res);
            this.op.onDataFetched && this.op.onDataFetched(res, this.added);
        });        
        
        this.offset = this.offset + this.loadingStep * 2;
    }
}

MediaScroller.prototype.init = function() {
    this.selectedImages = {};
    this.images = {};
    this.select_all = false;
    this.offset = 0;
    this.scope = '/processed'; //loads processed images, the other option is 'unprocessed'
}

MediaScroller.prototype.val = function(value) {
    if (value !== undefined) {

    }

    let hashes = [];
    if (this.scope === '/processed') {
        Object.keys(this.selectedImages).map(key => hashes.push(...JSON.parse(key)));
    }
    else {
        hashes = Object.keys(this.selectedImages);
    }
    
    return hashes;
}

MediaScroller.prototype.action = function (action) {
    if (action === 'deselect') {
        this.$el().find('div.selected').removeClass('selected');
        this.selectedImages = {};
        this.select_all = false;
    }
    else if (action === 'select_all') {
        this.select_all = true;
        this.$el().find('img').addClass('selected');
        Object.keys(this.images).map(key => {
            this.selectedImages[key] = this.images[key].$img;    
        });
    }
    else if (action === 'clear') {
        this.$el().empty();
        this.init();
    }
    else if (action === 'load_all' || action === 'load_processed') {
        this.action('clear');
        this.scope = '/processed';
        this._fetch();
    }
    else if (action === 'load_unprocessed') {
        this.action('clear');
        this.scope = '/unprocessed';
        this._fetch();
    }
    
    this.onMediaSelectionChanged && this.onMediaSelectionChanged();
}

MediaScroller.prototype.appendImages = function(res, observe = false) {

    const added = this.added = [];
    const self = this;

    const properties = {};

    const isProcessed = this.scope === '/processed';

    if (isProcessed) {
        res[1].map(r => {
            properties[r.file_hash] = JSON.parse(r.properties);
        });
        res = res[0];
    }
    else {
        res.map(r => {
            properties[r.file_hash] = JSON.parse(r.properties);
        });
    }

    for (let i=0; i<res.length; i++) {
        const im = res[i];

        if(isProcessed) {
            im.photos = Array.isArray(im.photos) ? JSON.stringify(im.photos) : im.photos;
            im.file_hash = im.photos;
            im.photos = JSON.parse(im.photos);
            im.currentPhotoInx = 0;
            im.currentPhotoHash = im.photos[0];
        }

        im.properties = properties[im.currentPhotoHash || im.file_hash];
        
        if (this.images[im.file_hash]) continue;

        let fileName = null;

        if (!isProcessed) {
            fileName = im.file_hash+'_thumbnail';
        }
        else {
            fileName = im.photos[0]+'_thumbnail';
        }

        const src = (fileName) => this.mediaRoot + '/m' + fileName.substring(0,2) + '/' + fileName + '/' + properties[isProcessed ? im.currentPhotoHash : im.file_hash].type;
        const $img = $(`<img style="max-height:160px; width: 160px" data-src="${im.file_hash}" src="${src(fileName)}">`);

        const $div = $('<div class="container"/>');
        $div.css('width', this.op.containerWidth || '180px');
        const $imgDiv = $('<div/>',{style: 'position: relative'}); //parent has to have relative or absolute position in order to avoid child is floating around when scrolling
        const $prop = $('<div/>',{style:'overflow:auto;max-height:160px'});

        if (this.scope === '/processed' && im.photos.length > 1) {
            const $group = $('<div class="btn-group" style="position: absolute;float:left;"/>');
            const $back = $('<button type="button" class="btn btn-default"><</button>');
            const $fwd = $('<button type="button" class="btn btn-default">></button>');    
            const $info = $('<button type="button" class="btn btn-default"></button>');
            
            $info.on('change',() => {
                const inx =  im.currentPhotoInx;
                $info.text((inx+1) + '/' + im.photos.length);
                $img.attr('src', src(im.photos[inx]+'_thumbnail'));
            });

            function imgMove(direction) {
                im.currentPhotoInx = Math.abs(im.currentPhotoInx+direction) % im.photos.length;
                const fileHash = im.photos[im.currentPhotoInx];
                im.properties = properties[fileHash];
                im.currentPhotoHash = fileHash;
                $info.trigger('change')
            }

            $back.on('click', ()=>imgMove(-1));
            $fwd.on('click', ()=>imgMove(1));
            
            $group.append($back);
            $group.append($info);
            $group.append($fwd);
            $imgDiv.append($group);
            $info.trigger('change');

        }
        
        $div.on('click', function(e) {
            
            if ( !e.ctrlKey ) {
                self.action('deselect');
            }
            
            const $img = $(this).find('img:first');
            const id = im.file_hash;
            
            if (self.selectedImages[id]) {
                $div.removeClass('selected');
                delete self.selectedImages[id];
            }
            else {
                $div.addClass('selected');
                self.selectedImages[id] = $img;
                if (self.onMediaSelected) {
                    self.onMediaSelected(im);
                }
            }
            self.onMediaSelectionChanged && self.onMediaSelectionChanged();
        });

        $imgDiv.append($img);
        $div.append($imgDiv);

        this.op.processAttributeValues && $prop.html(this.op.processAttributeValues(im));

        $div.append($prop);

        this.$el().append($div);
        added.push(im);

        if (this.select_all === true) {
            $div.addClass('selected');
            this.selectedImages[im.file_hash] = $img;
        }

        im.$img = $img;
        im.$div = $div;
        this.images[im.file_hash] = im;
    }

    if (observe === true && added.length > 0) {
        const $img = added[Math.floor(added.length/2)];
        this.observer.observe($img[0]);
    }
}

/* harmony default export */ __webpack_exports__["default"] = (MediaScroller);

/***/ })

}]);