(window["webpackJsonpmbase2modules"] = window["webpackJsonpmbase2modules"] || []).push([[24,26,63],{

/***/ 129:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// NAMESPACE OBJECT: ./src/modules/mbase2_ct/mapDataProcessor.js
var mapDataProcessor_namespaceObject = {};
__webpack_require__.r(mapDataProcessor_namespaceObject);
__webpack_require__.d(mapDataProcessor_namespaceObject, "default", function() { return mapDataProcessor; });
__webpack_require__.d(mapDataProcessor_namespaceObject, "onMarkerClicked", function() { return mapDataProcessor_onMarkerClicked; });

// EXTERNAL MODULE: ./src/app-globals.js
var app_globals = __webpack_require__(0);

// EXTERNAL MODULE: ./src/libs/exports.js
var libs_exports = __webpack_require__(7);

// EXTERNAL MODULE: ./src/helpers/onMarkerClicked.js
var onMarkerClicked = __webpack_require__(28);

// EXTERNAL MODULE: ./src/libs/utils.js
var libs_utils = __webpack_require__(8);

// EXTERNAL MODULE: ./src/libs/mbase2_utils.js
var mbase2_utils = __webpack_require__(12);

// EXTERNAL MODULE: ./src/libs/components/Map.js
var components_Map = __webpack_require__(16);

// EXTERNAL MODULE: ./src/libs/components/ModalDialog.js
var components_ModalDialog = __webpack_require__(17);
var ModalDialog_default = /*#__PURE__*/__webpack_require__.n(components_ModalDialog);

// CONCATENATED MODULE: ./src/modules/mbase2_ct/imagesOverview.js







/* harmony default export */ var imagesOverview = (async (op) => {

        const $container = $('<div/>');

        let imageMap = null;

        const {attributesKeyed, refValuesKeyed} = op;
        
        const $left =  $('<div style="float: left; width:450px"/>');
        const $right = $('<div style="float: right; height:100%; width:calc(100% - 450px); max-height: calc(100vh - 187px); border-left: solid black 1px; padding:10px"/>');
        
        const $stationMap = $('<div/>',{'style':'width:100%; height:300px'});
        const $map = $('<div style="height:80vh"/>');
        
        const $mediaScroller =  $('<div style="height:100%; max-height: calc(80vh - 300px); overflow-y: auto"/>');

        $left.append($stationMap);
        $left.append($mediaScroller);
        
        $right.append($map);
        
        $container.append($left);
        $container.append($right);

        let selectedImage = null;
    
        const mediaScroller = new (await Object(libs_exports["MediaScroller"])()).default({
            mediaRoot: app_globals["a" /* default */].mediaRoot + op.mediaRootFolder,
            fetch: async (offset, scope = '/') => {
                const data = op.data;
                return [data, op.fileProperties];
            },
            containerWidth: '420px',
            processAttributeValues: (row) => {
                const clonedRow = Object.assign({}, row);
                mbase2_utils["processAttributeValues"](clonedRow, attributesKeyed, refValuesKeyed);
                const output = [];
                Object.keys(clonedRow).map(key => {
                    const a = attributesKeyed[key];
                    if (a) {
                        const label =  a.t_name_id || a.key_name_id;
                        output.push(`<b>${label}:</b> ${clonedRow['t_'+key] || clonedRow[key]}`);
                    }
                });
                
                return output.join('<br>');    
            },
            onMediaSelected: mediaData => {
                imageMap = components_Map["leafletPreview"](imageMap, $map, app_globals["a" /* default */].mediaRoot + op.mediaRootFolder + mbase2_utils["filePath"](mediaData.currentPhotoHash || mediaData.file_hash), mediaData.properties);
            },
            onDataFetched: (res, added) => {
                selectedImage = added.find(im => im.file_hash === op.selectedMedia.file_hash);
            }
        });

        $mediaScroller.append(mediaScroller.$el());

        const modal = new ModalDialog_default.a({
            size: 'modal-xxl',
            onShown:()=>{
                const map = new components_Map["default"]({
                    $container: $stationMap
                });

                const {markers} = map.addLayer([op.geom],'ct',op.grid ? 'grid' : 'detail');

                const marker = markers[0];
                marker.getPopup().setContent('<h5>'+op.stationName+'</h5><br>'+`<b>${libs_utils["t"]`Number of photos`}:</b> ${op.numberOfPhotos}`);
                marker.openPopup();

                if (selectedImage) {
                    selectedImage.$div.trigger('click');
                    selectedImage.$div[0].scrollIntoView();
                }
                 
                selectedImage = null;
            }
        });
        //modal.$body.css('height', '90vh');
        modal.$body.html($container);
        modal.show();

});
// CONCATENATED MODULE: ./src/modules/mbase2_ct/mapDataProcessor.js






/**
 * ct map data processor
 */

/* harmony default export */ var mapDataProcessor = (op => {

    const stationData = {};

    const t = libs_utils["t"];

    for (const sighting of op.result) {
        if (!stationData[sighting.trap_station_name]) stationData[sighting.trap_station_name] = [];
        stationData[sighting.trap_station_name].push(sighting);
    }

    const data = [];

    const adef = op.attributes.find(a => a.key_name_id == 'trap_station_name');

    Object.keys(stationData).map(key => {
        const sightings = stationData[key];

        const stationName = op.refValues.tableReferences.find(r => r._id_list_id === key+'_'+adef.ref).key;
        
        data.push({
            geom: sightings[0].geom,
            data: {
                sightings,
                stationName,
                rows: op.result,
                grid: op.grid,
                fileProperties: op.fileProperties,
                stationKey: key
            }
        });

    });

    return data;
});

const mapDataProcessor_onMarkerClicked = async (marker, row, op) => {
    
    const $container = $('<div/>');
    $container.css('width', '450px');

    const popup = marker.getPopup();

    const t = libs_utils["t"];

    popup.setContent($container[0]);
    
    const $div = $(popup.getElement()).find('.leaflet-popup-content:first');
    $div.css('min-width', '450px');

    const {sightings, stationName} = row;
    
    const photos = {};
    sightings.map(record => {
        record.photos = libs_utils["jsonParse"](record.photos);
        record.photos.map(photo => photos[photo] = true);
    });
    
    const numberOfPhotos = Object.keys(photos).length;

    $container.html('<h3>'+stationName+'</h3>');
    $container.append(`<b>${t`Number of records`}:</b> ${sightings.length}`);
    $container.append('<br>');
    $container.append(`<b>${t`Number of photos`}:</b> ${numberOfPhotos}`);
    $container.append('<hr>');

    const $mediaContainer = $('<div/>');

    $mediaContainer.css('width', '100%');
    $mediaContainer.css('max-height', '50vh');
    $mediaContainer.css('overflow-y', 'auto');

    $container.append($mediaContainer);

    const stationKey = row.stationKey;

    const data = row.rows.filter(r=>r.trap_station_name == stationKey);

    const mediaRootFolder = '/private/ct';

    const {attributesKeyed, refValuesKeyed} = op.moduleAttributes;
                    
    const mediaScroller = new (await Object(libs_exports["MediaScroller"])()).default({
        mediaRoot: app_globals["a" /* default */].mediaRoot + mediaRootFolder,
        fetch: async (offset, scope = '/') => {
            return [data, row.fileProperties];
        },
        containerWidth: '420px',
        processAttributeValues: (row) => {
            const clonedRow = Object.assign({}, row);
            mbase2_utils["processAttributeValues"](clonedRow, attributesKeyed, refValuesKeyed);
            const output = [];
            Object.keys(clonedRow).map(key => {
                const a = attributesKeyed[key];
                if (a) {
                    const label =  a.t_name_id || a.key_name_id;
                    output.push(`<b>${label}:</b> ${clonedRow['t_'+key] || clonedRow[key]}`);
                }
            });
            
            return output.join('<br>');    
        },
        onMediaSelected: mediaData => {
            imagesOverview({
                selectedMedia: mediaData,
                result: row.rows,
                grid: row.grid,
                fileProperties: row.fileProperties,
                mediaRootFolder: mediaRootFolder,
                data: data,
                attributesKeyed: attributesKeyed,
                refValuesKeyed: refValuesKeyed,
                geom: {geom: sightings[0].geom},
                stationName: stationName,
                numberOfPhotos: numberOfPhotos
            });                        
        }
    });

    $mediaContainer.append(mediaScroller.$el());
    popup.update();
}
// CONCATENATED MODULE: ./src/modules/moduleSpecificMapDataHandlers.js
/**
 * Functions that deal with data presentation for specific modules - don't add additional object properties here, use existing variables keys
 */
/* harmony default export */ var moduleSpecificMapDataHandlers = ((moduleKey, data) => {

    if (!data) return data;

    const handlers = {
        dmg:{
            _zgs_damage_objects: (value) => {   //group and count zgs damage objects
                value=JSON.parse(value);
                const out={};
                value.map(v => out[v] = (out[v] || 0) + 1);
                return Object.keys(out).map(key => `${key}:  ${out[key]}x`).join(', ');
            }
        }
    }

    const handler = handlers[moduleKey];

    if (!handler) return {...data};

    const out = {};

    Object.keys(data).map(key => {
        out[key] = handler[key] ? handler[key](data[key]) : data[key];
    });

    return out;
});
// CONCATENATED MODULE: ./src/modules/mbase2_data_query/index.js
/**
 * @param {object} op options
 * @param {object} op.$parent
 * @param {string} op.tname
 */








/* harmony default export */ var mbase2_data_query = __webpack_exports__["default"] = (async op => {
    const {$parent} = op;

    let query = {};

    const [
        Map,
        Sidebar,
        mutils,
        utils,
        ComponentManager,
        Button,
        Alert,
        DataFilter,
        DateInputs,
        ModalDialog
    ] = await Promise.all([
        libs_exports["Map"](),
        libs_exports["Sidebar"](),
        libs_exports["mutils"](),
        libs_exports["utils"](),
        libs_exports["ComponentManager"](),
        libs_exports["Button"](),
        libs_exports["Alert"](),
        libs_exports["DataFilter"](),
        libs_exports["DateInputs"](),
        libs_exports["ModalDialog"]()
    ]);

    await DataFilter.loadExports(libs_exports);

    const t = utils.t;

    let _state = null; //_state = detail/grid

    //Module variables

    const mapLayers = {};
    const cachedAttributes = {};
    const cachedFilters = {};

    ///////Leaflet Map

    const map = new Map.default({
        $container: $parent,
        stateChangingButton: {
            detail: t`show grid data`,
            grid: t`show detail points`
        },
        onSwitchState: state => {
            _state = state;
            executeQuery();
        },
        onMarkerClicked: (marker, row, moduleKey) => {  
            const moduleAttributes = cachedAttributes[moduleKey];
            if (moduleKey === 'ct') {
                mapDataProcessor_onMarkerClicked(marker, row, {moduleKey, moduleAttributes});
            }
            else {
                const data = moduleSpecificMapDataHandlers(moduleKey, row);
                Object(onMarkerClicked["a" /* onMarkerClicked */])(marker, data, {moduleKey, moduleAttributes});
            }
        },
        centerPopupOnOpen: true,
        scaleControl: true
    });

    const sidebarContainer = new Sidebar.default({id:'leaflet-sidebar',title: t`Database`,$container: $parent});
    const sidebar = map.addSidebar('leaflet-sidebar');

    let modules = await mutils.requestHelper(app_globals["a" /* default */].apiRoot + `/modules/language/${app_globals["a" /* default */].language}`);

    modules = modules.filter(m => m.key_id !== 'mbase2');

    modules.map(m => {
        m.color = JSON.parse(m.properties).color;
        m._id = m.id;
        m.id = m.key_id;
    });

    const $sidebarContainer = sidebarContainer.$el().find('#home .container-fluid:first');
    const components = {
        modules: {
            module: libs_exports["EventsLegend"],
            options: {
                rows: modules,
                onDataFilter: (moduleName) => {
                    
                },
                onChange: onLegendChanged
            },
            $parent: $sidebarContainer
        }
    }

    const cm = new ComponentManager.default({
        onComponentChange: (key, value, cm) => {
            updateQuery();
        }
    });
    await utils.loadComponents(components);
    const legendCmp = await cm.add(components.modules);
    $sidebarContainer.append('<br>');

    // date selector
    await cm.add({
        key: 'event_date',
        component: DateInputs.DateSpan,
        $parent: $sidebarContainer,
        options:{
            labelStartDate:t`Start date`,
            labelEndDate:t`End date`,
            format:'YYYY-MM-DD',
            date1:'2018-01-01',
            date2: moment(),
            //label: attributes[key].t_name_id || key,
            required: true,
            //disabled: disabled,
            onChange: (component) => {
                const cmp = cm.get('event_date');
                cmp && cmp.$el().trigger('change')
            }
        }
    });

    const msg = new Alert.default({type: 'warning'});
    $sidebarContainer.append('<br>');
    $sidebarContainer.append(msg.$el());
    msg.$el().hide();
    msg.val(t`You have changed the query criteria. For the changes to take effect you have to press the "Execute query" button.`);

    sidebar.open('home');
    
    const executeQueryBtn = new Button.default({
        label: t`Execute query`,
        classes: 'btn-lg',
        iconClass: 'bolt',
        onClick: executeQuery
    });

    const shareDataBtn = new Button.default({
        label: t`Share data`,
        classes: 'btn-lg',
        iconClass: 'share-alt',
        onClick: shareData
    })

    executeQueryBtn.$el().find('button').prop('disabled', true);
    
    const $btnDiv = $('<div/>', {style: 'display: flex; float: right'});

    shareDataBtn.$el().css('margin-right', '10px');

    $btnDiv.append(shareDataBtn.$el());

    $btnDiv.append(executeQueryBtn.$el());

    //cm.get('filter').val(JSON.parse('[["_species_name","=","1046"],["_licence_name","=","10"],["sighting_quantity",">","1"]]'));

    /*
    const articleBtn = new Button.default({
        label: t`Edit article`,
        classes: 'btn-lg',
        style: 'float: left',
        iconClass:'fa fa-address-card-o'
    });
    $btnDiv.append(articleBtn.$el());
    */

    $btnDiv.append('<div style="clear: both;"></div>');

    $sidebarContainer.append('<br>');
    $sidebarContainer.append($btnDiv);

    query = cm.val();   //initial value

    //
    //cm.get('modules').val(['ct']);
    //cm.get('modules').$el().find('input').trigger('change');
    //

    /**callbacks */
    function onCachedAttributesLoaded() {
        executeQueryBtn.$el().find('button').prop('disabled', false);
        executeQuery();
    }

    async function executeQuery() {
        const nquery = cm.val();
        console.log('nquery', nquery, cachedFilters)

        const grid = _state==='grid' ? 1 : 0;
        
        const promisses = nquery.modules.map(m => {
            mapLayers[m] && map.map.removeLayer(mapLayers[m].group);
            const filter = [...nquery.event_date, ...cachedFilters[m].val()];
            const __filter = mutils.prepareFilter(filter, false);
            const viewName = m+'_vw';
            return mutils.requestHelper(app_globals["a" /* default */].apiRoot + `/mb2data/${viewName}/language/${app_globals["a" /* default */].language}${__filter}&:__grid=${grid}`);
        });

        let cnt = 0;
        const nrequests = promisses.length;

        promisses.map((promise, i) => promise.then(res => {
            let mapData = res;
            const moduleName = nquery.modules[i];

            const moduleAttributes = cachedAttributes[moduleName];

            if (moduleName === 'ct') {
                console.log(mapDataProcessor_namespaceObject)
                mapData = mapDataProcessor({
                    result: res,
                    grid: grid,
                    attributes: moduleAttributes.attributes,
                    refValues: moduleAttributes.refValues,
                    fileProperties: cachedAttributes[moduleName].additional.fileProperties,
                    attributesKeyed: moduleAttributes.attributesKeyed,
                    refValuesKeyed: moduleAttributes.refValuesKeyed
                });
            }

            const props = JSON.parse(modules.find(m => m.id === moduleName).properties);
            
            mapLayers[moduleName] = map.addLayer(mapData, moduleName, null, props);
            if (nrequests === ++cnt) {  //if all requests are done
                msg.$el().hide();
            }
        }));
    }
    
    /**utils */
    function updateQuery() {
        const nquery = cm.val();

        if (_.isEqual(query, nquery)) {
            msg.$el().hide();
        }
        else {
            msg.$el().show();
        }
    }
    /*
    const variables = mutils.getModuleVariables(moduleId);
    const tableRecordsOptions = await mutils.generalTableRecordsOptions($parent, tableName, variables);
    tableRecordsOptions.url = globals.apiRoot + `/mb2data/${tableName}/language/${globals.language}`;  
    const recordsTable = await import('./recordsTable');
    await recordsTable.default(tableRecordsOptions);
    */

    async function shareData() {
        const md = new ModalDialog.default();
        md.$title.html('Share mbase data')

        const button = new Button.default({
            label:'OK'
        });

        md.$body.html('<a href="https://portal.mbase.org/mbase2/map/1WX0Iaq0PJBxa8BwwOBaO3UvUpjvXiSn">https://portal.mbase.org/mbase2/map/1WX0Iaq0PJBxa8BwwOBaO3UvUpjvXiSn</a>');

        md.$footer.append(button.$el());
        
        md.show();
    }

    async function onLegendChanged(moduleName, state) {
        
        if (state === true) {
            if (!cachedAttributes[moduleName]) {
                executeQueryBtn.$el().find('button').prop('disabled', true);

                let additional = {};

                const attributes = (await mutils.getModuleVariables(moduleName, true, false, true)).filter(a => a.visible === true && a.visible_in_table === true);

                if (moduleName === 'ct') {
                    additional.fileProperties = await mutils.requestHelper(app_globals["a" /* default */].apiRoot + `/mb2data/ct_view_file_properties`);
                }
                
                const refValues = await mutils.getRefCodeListValues(attributes);
                const attributesKeyed = utils.arrayToObject(attributes, 'key_name_id');
                const refValuesKeyed = await mutils.convertReferencesToAssocArray(refValues);
                cachedAttributes[moduleName] = {attributes, refValues, attributesKeyed, refValuesKeyed, additional};

                cachedFilters[moduleName] = new DataFilter.default({
                        attributesDefinition: attributes.filter(a=>a.filterable === true),
                        refValues: refValues,
                        $filter: legendCmp.$el().find(`.legend-item-filter[data-id='${moduleName}']`),
                        apply: {
                            button:{label: t`Execute query`},
                            callback: () => executeQuery()
                        }
                });
            }

            onCachedAttributesLoaded(moduleName);
        }
        else {
            mapLayers[moduleName] && map.map.removeLayer(mapLayers[moduleName].group);
        }
    }

});

/***/ }),

/***/ 16:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "leafletPreview", function() { return leafletPreview; });
/* harmony import */ var leaflet_easybutton__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29);
/* harmony import */ var leaflet_easybutton__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet_easybutton__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var leaflet_easybutton_src_easy_button_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);
/* harmony import */ var leaflet_easybutton_src_easy_button_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(leaflet_easybutton_src_easy_button_css__WEBPACK_IMPORTED_MODULE_1__);

  
  

  //https://gis.stackexchange.com/questions/197882/is-it-possible-to-cluster-polygons-in-leaflet
	L.PolygonClusterable = L.Polygon.extend({
	  _originalInitialize: L.Polygon.prototype.initialize,
	  
	  initialize: function (bounds, options) {
		this._originalInitialize(bounds, options);
		this._latlng = this.getBounds().getCenter();
	  },
	  
	  getLatLng: function () {
		return this._latlng;
	  },
	  
	  // dummy method.
	  setLatLng: function () {}
	});

  const pdefs = {
    3794: '+proj=tmerc +lat_0=0 +lon_0=15 +k=0.9999 +x_0=500000 +y_0=-5000000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs',
    3912: '+proj=tmerc +lat_0=0 +lon_0=15 +k=0.9999 +x_0=500000 +y_0=-5000000 +ellps=bessel +towgs84=409.545,72.164,486.872,3.085957,5.469110,-11.020289,17.919665 +units=m +no_defs',
    4326: '+proj=longlat +datum=WGS84 +no_defs',
    3035: '+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs'
  };

  /**
   * 
   * @param {boolean} centerPopupOnOpen 
   */
  var Map=function(op = {}){
    this.op=op;
    const center = this.op.center || [46.119944, 14.81533];
    const zoom = this.op.zoom || 8;

    this.$el = () => op.$container;

    this.$el().css('font-size','11px'); //temporary solution for patternfly css interference with leaflet font size

    this.__state = 'detail';

    const mapOptions = { zoomControl: false, preferCanvas: true };

    if (op.zoomDelta !== undefined) mapOptions.zoomDelta = op.zoomDelta;
    if (op.zoomSnap !== undefined) mapOptions.zoomSnap = op.zoomSnap;

    const map = this.map = L.map(this.op.$container[0], mapOptions).setView(center, zoom);

    const baseMaps = {
      "OpenStreetMap": L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
      })
    };

    /*
    baseMaps.DOF = L.tileLayer.wms("http://prostor4.gov.si:80/ows2-m-pub/wms?", {
      layers:"SI.GURS.ZPDZ:DOF050",
      maxNativeZoom: 19,
      maxZoom: 23,
      attribution: '<a href="http://www.e-prostor.gov.si/dostop-do-podatkov/dostop-do-podatkov/#c501">Geodetska uprava Republike Slovenije</a>'
    });
    */

    const mbAttr = 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community';

    const mbUrl = 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}';

    baseMaps['ESRI World Imagery'] = L.tileLayer(mbUrl, {
      id: 'esri',
      attribution: mbAttr
    });

    const overlays = {};

    L.control.layers(baseMaps, overlays).addTo(map);

    baseMaps['OpenStreetMap'].addTo(map);

    op.scaleControl && L.control.scale({
      position: 'bottomright'
    }).addTo(map);

    new L.Control.Zoom({ position: 'bottomright' }).addTo(map);

    if (op.stateChangingButton) {
      map.stateChangingButton = L.easyButton({
        position:'topright',
        id:'grid-detail-switch',
        states: [{
          stateName: 'detail',
          icon:      'fa-th',
          title:     op.stateChangingButton.detail.title,
          onClick: (btn, map) => this.switchState(btn, map, 'grid')
        },
        {
          stateName: 'grid',        // name the state
          icon:      'fa-map-marker',               // and define its properties
          title:     op.stateChangingButton.grid.title,      // like its title
          onClick: (btn, map) => this.switchState(btn, map, 'detail')
        }
      ]
      }).addTo(map);
    }

	};

  Map.prototype.switchState=function(btn,map,state) {
    if (btn === null) btn = this.map.stateChangingButton;
		if (map === null) map = this.map;
		btn.state(state);
    this.__state = state;
    this.op.onSwitchState && this.op.onSwitchState(state);
  }
  
  Map.prototype.addSidebar=function(sidebarId){
    return L.control.sidebar(sidebarId).addTo(this.map);
  };

  Map.prototype.zoomToMarker = function (marker, data) {
    const markerClusterGroup = this.layerGroup;

    const visibleParent = markerClusterGroup.getVisibleParent(marker); //returns marker if visible

    if (visibleParent === marker) {
        this.op.onMarkerClicked(marker, data);
        marker.openPopup();
    }
    else {
      if (this.map.getZoom()<this.map.getMaxZoom()) { //prevent endless loop in case visibleParent === marker condition is not reached (for example when we have two markers at the same spot)
        this.map.setView(marker.getLatLng(), this.map.getZoom()+1, true);
        setTimeout(() => this.zoomToMarker(marker,data),20)
      }
    }
    
}


  Map.prototype.getGridCellCoordinates = function(c, gridCellSize=1000) {
    
    if (!gridCellSize) gridCellSize=1000;

    const c0 = proj4(pdefs['3035'], pdefs['4326'], [c[1], c[0]]);
    return [c0,
        proj4(pdefs['3035'], pdefs['4326'], [c[1]+gridCellSize, c[0]]),
        proj4(pdefs['3035'], pdefs['4326'], [c[1]+gridCellSize, c[0]+gridCellSize]),
        proj4(pdefs['3035'], pdefs['4326'], [c[1], c[0]+gridCellSize]),
      c0].map(c => [c[1], c[0]]);
  }
  
  /**
   * 
   * Adds data array layer to map and assigns __marker reference to each row of the data
   * 
   * @param {Object[]} res coordinates, two types of input 
   * @param {string} [res[].geom]
   * @param {number} [res[]]
   * @param {string} moduleName module key
   * @param {string} state 'grid' or 'detail', if null this.__state is used
   * @param {Object} [props]
   * @param {string} props.grid_size grid size in meters
   * @param {string} props.color hex value of grid cell color (e.g. "#d211ec") 
   * @returns 
   */

  Map.prototype.addLayer = function(res, moduleName, state = null, props={}) {
    if (state!==null) this.__state = state;
    
    const layerGroup = this.layerGroup = this.__state==='grid' ? L.layerGroup() : L.markerClusterGroup();

    const markers = [];

    res.map(r => {
      let c = null;
      if (r.geom) {
        const geom = JSON.parse(r.geom);
        c = geom.coordinates.reverse();
      }
      else if (r.c) {
        c = r.c;
      }

      let marker = null;

      if (this.__state==='grid') { //create grid cells
        
        const cellc = this.getGridCellCoordinates(c, props && parseFloat(props.grid_size));

          const clsFun = L.Polygon; //clsFun = L.PolygonClusterable;
          const layerOptions = {};

          if (props && props.color) {
            layerOptions.color = props.color;
          }

          marker = new clsFun(cellc, layerOptions);
            //https://en.wikipedia.org/wiki/Alpha_compositing
            //polygon.setStyle({fillOpacity: 1.0 - 0.5/(detail.__cnt?detail.__cnt:1), fillColor: fillColor,color:fillColor});
      }
      else {
        marker = L.marker(c);
      }

      marker.bindPopup();

      r.__marker = marker;

      if (this.op.onMarkerClicked) {
        marker.on('click', () => this.op.onMarkerClicked(marker,r.data || r, moduleName));
      }
      
      c && markers.push(marker) && layerGroup.addLayer(marker);
  });
    
    this.map.addLayer(layerGroup);

    const self = this;

    if (this.op.centerPopupOnOpen || this.op.onPopupOpened) {
      
      layerGroup.on('popupopen', function(e) {

        if (self.op.centerPopupOnOpen) {
          setTimeout(() => {
              e.popup.update();
              setTimeout(() => {
                  const popupPosition = e.popup.getLatLng();
                  const mapCenter = self.map.getCenter();
                  self.map.panTo({lat: mapCenter.lat, lng: popupPosition.lng});
              }, 300);
          }, 100);
        }

        self.op.onPopupOpened && self.op.onPopupOpened(e, moduleName);
      });
    }

    return {markers,group:layerGroup};
  }

  const leafletPreview = (map, $map, src, props) => {
    if (!props.height || !props.width) return null;
    if (!map) {
      map = L.map($map[0], {
          crs: L.CRS.Simple,
          minZoom: 1,
          maxZoom: 5,
          center: [0, 0],
          zoom: 1,
          zoomDelta: 0.25,
          zoomSnap: 0
      });

      L.easyButton('fa-download', function(btn, map){
        downloadImage();
      }).addTo(map);

      L.easyButton('<span style="font-size: 1.5em;">&target;</span>', function(btn, map){
        fitBounds();
      }, 'Reset to initial view').addTo(map);
    }
    
    function downloadImage() {
      var a = $("<a>")
          .attr("href", src + '/' + props.type)
          .attr("download", "img." + props.type)
          .appendTo("body");

      a[0].click();

      a.remove();
    }
                
    const h = props.height;
    const w = props.width;
    var southWest = map.unproject([0, h], map.getMaxZoom()-1);
    var northEast = map.unproject([w, 0], map.getMaxZoom()-1);
    var bounds = new L.LatLngBounds(southWest, northEast);

    map.eachLayer(function (layer) {
        map.removeLayer(layer);
    });

    //var bounds = [[0,0], [props.height, props.width]];
    var image = L.imageOverlay(src, bounds).addTo(map);

    function fitBounds() {
      map.fitBounds(bounds);
    }
    
    fitBounds();

    return map;
}
  
  /* harmony default export */ __webpack_exports__["default"] = (Map);

/***/ }),

/***/ 17:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){
	var tpl='<div class="modal-dialog modal-lg">'+
			'<div class="modal-content">'+
			  '<div class="modal-header">'+
				'<button type="button" class="close" data-dismiss="modal" aria-hidden="true">'+
				  '<span class="pficon pficon-close"></span>'+
				'</button>'+
				'<h4 class="modal-title" id="myModalLabel"></h4>'+
			  '</div>'+
			  '<div>'+
				'<div class="modal-body"  style="max-height:85vh; overflow-y:auto">'+
				'</div>'+
				'<div class="modal-footer">'+
				'</div>'+
			  '</div>'+
			'</div>'+
		  '</div>';
		  
	var tpl2='<div class="modal-content">'+
                '<div class="popup_header">'+
                    '<span class="close">&times;</span>'+
					'<h4 class="modal-title"></h4>'+
                '</div>'+
                '<div class = "popup_content_container modal-body">'+
                '</div>'+
				'<div class = "popup_content_container modal-footer">'+
                '</div>'+
              '</div>';
		  
	var ModalDialog=function(op){
		if (!op) op={};
		this.modalOptions = {};
		if (op.backdrop === undefined) op.backdrop = 'static';
		if (op.keyboard === undefined) op.keyboard = true;	//this is not working
		this.modalOptions.backdrop = op.backdrop;
		this.modalOptions.keyboard = op.keyboard;
		var id='mdlg-'+(new Date()).getTime();
		var $modal=this.$modal=$('<div/>',{
			'class':op.tpl==2?"overlay":"modal fade",
			//'tabindex':"-1", //has to be removed in order for select2 search box to work
			'role':"dialog",
			'aria-hidden':"true",
			id:id
		});

		this.$el = () => $modal;
		
		if (op.tpl==2)
			$modal.html(tpl2);
		else
			$modal.html(tpl);
		
		if (op.size){
			$modal.find('.modal-dialog').removeClass('modal-lg').addClass(op.size);	
		}

		if (op.maxWidth) {
			$modal.find('.modal-dialog').css('max-width', op.maxWidth);
		}
		
		this.$body=$modal.find('.modal-body').first();
		this.$title=$modal.find('.modal-title').first();
		this.$footer=$modal.find('.modal-footer').first();
		this.$contentDiv=$modal.find('.modal-content').first();
		
		if (op.onShown){
			$modal.on('shown.bs.modal',function(){
				op.onShown();
			});
		}
		
		var that=this;
		
		if (op.acceptBtn){
			var $btn=$('<button type="button" class="btn btn-default">'+op.acceptBtn.text+'</button>');
			
			if (op.acceptBtn.typeClass!==undefined) {
				$btn.removeClass('btn-default').addClass('btn-'+op.acceptBtn.typeClass);
			}
			
			this.$footer.append($btn);
			$btn.click(function(){
				if (op.acceptBtn.callback) op.acceptBtn.callback($btn);
			});
		}
    
		if (op.onClose){
			$modal.on('hidden.bs.modal',function(){
				op.onClose();
			});
		}
		
		if (op.tpl==2) {
			$modal.modal=function(action){
				if (action==='show'){
					that.$contentDiv.parent().css({'display': 'inline'});
					that.$modal.trigger('shown.bs.modal');
				}
				else if (action==='hide'){
					that.$contentDiv.parent().css({'display': 'none'});
				}
			};
			
			$modal.find('.close').click(function(){
				that.$contentDiv.parent().css({'display': 'none'});
			});
			
			$('body').prepend($modal);
		}
	};
	
	ModalDialog.prototype.destroy=function(){
		var $backdrop=this.$modal.data()['bs.modal'].$backdrop;
		var $dialog=this.$modal.data()['bs.modal'].$dialog;
		var $element=this.$modal.data()['bs.modal'].$element;
		if ($backdrop) $backdrop.remove();
		if ($dialog) $dialog.remove();
		if ($element) $element.remove();
		this.$modal.data('bs.modal',null);
		this.$modal.remove();
	};
		
	ModalDialog.prototype.show=function(){
		$('#mbaselaravel').append(this.$el());
		this.$modal.modal(this.modalOptions);
	};
		
	ModalDialog.prototype.hide=function(){
		this.$modal.modal('hide');
	};
	
	return ModalDialog;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ 28:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return onMarkerClicked; });
/* harmony import */ var _libs_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _app_globals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);



/**
 * 
 * @param {object} marker 
 * @param {object} row 
 * @param {object} op
 * @param {object} [op.dataTable] DataTable component (used for collecting formated and translated data)
 * @param {object} op.moduleKey
 * @param {object} [op.moduleAttributes] module attributes definitions (not needed if op.dataTable is present)
 * @param {object} op.moduleAttributes.attributes
 * @param {object} op.moduleAttributes.attributesKeyed
 * @param {object} [op.moduleAttributes.refValues]
 * 
 */

const onMarkerClicked = async (marker, row, op) => {

    const [
        ImageArray,
        mutils,
        ImageViewer
    ] = await Promise.all([
        _libs_exports__WEBPACK_IMPORTED_MODULE_0__["ImageArray"](),
        _libs_exports__WEBPACK_IMPORTED_MODULE_0__["mutils"](),
        _libs_exports__WEBPACK_IMPORTED_MODULE_0__["ImageViewer"]()
    ]);

    const {dataTable, moduleKey, moduleAttributes} = op;
        
    const rowInx = (row && row.__rowInx) || row;

    if (rowInx) {
        
        let photos = null;
        let popupContent = '';
        
        if (dataTable) { //use dataTable formatted and translated data if dataTable is defined
            const lines = [];
            dataTable.getRowCellsFormattedData(rowInx).map(o => {
                if (o.data !== '_photos') {
                    lines.push(`<b>${o.title}:</b> ${o.value}`);
                }
            });
            popupContent = lines.join('<br>');
        }
        else {
            popupContent = mutils.attributeValuesToHtml(row, moduleAttributes.attributesKeyed,'<br>',moduleAttributes.attributes.map(a=>a.key_name_id), true, moduleAttributes.refValues, ['_photos']);
        }

        if (row._photos) {
            photos = row._photos && JSON.parse(row._photos);
        }
        
        const popup = marker.getPopup();
        popup.setContent(popupContent);

        if (photos) {
            const $div = $(popup.getElement()).find('.leaflet-popup-content:first');
            const cmp = new ImageArray.default({
                mediaRoot: _app_globals__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].mediaRoot+'/private/'+moduleKey, 
                skipAddButton: true,
                onClick: async () => {
                    await ImageViewer.default({
                        data: photos.map(p => ({
                            file_hash:p,
                            properties: '{}'
                        })),
                        mediaRootFolder: _app_globals__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].mediaRoot+'/private/'+moduleKey
                    });
                }
            });
            $div.append(cmp.$el());
            cmp.val(photos);
        }

        return popup;
    }
}

/***/ }),

/***/ 29:
/***/ (function(module, exports) {

(function(){

// This is for grouping buttons into a bar
// takes an array of `L.easyButton`s and
// then the usual `.addTo(map)`
L.Control.EasyBar = L.Control.extend({

  options: {
    position:       'topleft',  // part of leaflet's defaults
    id:             null,       // an id to tag the Bar with
    leafletClasses: true        // use leaflet classes?
  },


  initialize: function(buttons, options){

    if(options){
      L.Util.setOptions( this, options );
    }

    this._buildContainer();
    this._buttons = [];

    for(var i = 0; i < buttons.length; i++){
      buttons[i]._bar = this;
      buttons[i]._container = buttons[i].button;
      this._buttons.push(buttons[i]);
      this.container.appendChild(buttons[i].button);
    }

  },


  _buildContainer: function(){
    this._container = this.container = L.DomUtil.create('div', '');
    this.options.leafletClasses && L.DomUtil.addClass(this.container, 'leaflet-bar easy-button-container leaflet-control');
    this.options.id && (this.container.id = this.options.id);
  },


  enable: function(){
    L.DomUtil.addClass(this.container, 'enabled');
    L.DomUtil.removeClass(this.container, 'disabled');
    this.container.setAttribute('aria-hidden', 'false');
    return this;
  },


  disable: function(){
    L.DomUtil.addClass(this.container, 'disabled');
    L.DomUtil.removeClass(this.container, 'enabled');
    this.container.setAttribute('aria-hidden', 'true');
    return this;
  },


  onAdd: function () {
    return this.container;
  },

  addTo: function (map) {
    this._map = map;

    for(var i = 0; i < this._buttons.length; i++){
      this._buttons[i]._map = map;
    }

    var container = this._container = this.onAdd(map),
        pos = this.getPosition(),
        corner = map._controlCorners[pos];

    L.DomUtil.addClass(container, 'leaflet-control');

    if (pos.indexOf('bottom') !== -1) {
      corner.insertBefore(container, corner.firstChild);
    } else {
      corner.appendChild(container);
    }

    return this;
  }

});

L.easyBar = function(){
  var args = [L.Control.EasyBar];
  for(var i = 0; i < arguments.length; i++){
    args.push( arguments[i] );
  }
  return new (Function.prototype.bind.apply(L.Control.EasyBar, args));
};

// L.EasyButton is the actual buttons
// can be called without being grouped into a bar
L.Control.EasyButton = L.Control.extend({

  options: {
    position:  'topleft',       // part of leaflet's defaults

    id:        null,            // an id to tag the button with

    type:      'replace',       // [(replace|animate)]
                                // replace swaps out elements
                                // animate changes classes with all elements inserted

    states:    [],              // state names look like this
                                // {
                                //   stateName: 'untracked',
                                //   onClick: function(){ handle_nav_manually(); };
                                //   title: 'click to make inactive',
                                //   icon: 'fa-circle',    // wrapped with <a>
                                // }

    leafletClasses:   true,     // use leaflet styles for the button
    tagName:          'button',
  },



  initialize: function(icon, onClick, title, id){

    // clear the states manually
    this.options.states = [];

    // add id to options
    if(id != null){
      this.options.id = id;
    }

    // storage between state functions
    this.storage = {};

    // is the last item an object?
    if( typeof arguments[arguments.length-1] === 'object' ){

      // if so, it should be the options
      L.Util.setOptions( this, arguments[arguments.length-1] );
    }

    // if there aren't any states in options
    // use the early params
    if( this.options.states.length === 0 &&
        typeof icon  === 'string' &&
        typeof onClick === 'function'){

      // turn the options object into a state
      this.options.states.push({
        icon: icon,
        onClick: onClick,
        title: typeof title === 'string' ? title : ''
      });
    }

    // curate and move user's states into
    // the _states for internal use
    this._states = [];

    for(var i = 0; i < this.options.states.length; i++){
      this._states.push( new State(this.options.states[i], this) );
    }

    this._buildButton();

    this._activateState(this._states[0]);

  },

  _buildButton: function(){

    this.button = L.DomUtil.create(this.options.tagName, '');

    if (this.options.tagName === 'button') {
        this.button.setAttribute('type', 'button');
    }

    if (this.options.id ){
      this.button.id = this.options.id;
    }

    if (this.options.leafletClasses){
      L.DomUtil.addClass(this.button, 'easy-button-button leaflet-bar-part leaflet-interactive');
    }

    // don't let double clicks and mousedown get to the map
    L.DomEvent.addListener(this.button, 'dblclick', L.DomEvent.stop);
    L.DomEvent.addListener(this.button, 'mousedown', L.DomEvent.stop);
    L.DomEvent.addListener(this.button, 'mouseup', L.DomEvent.stop);

    // take care of normal clicks
    L.DomEvent.addListener(this.button,'click', function(e){
      L.DomEvent.stop(e);
      this._currentState.onClick(this, this._map ? this._map : null );
      this._map && this._map.getContainer().focus();
    }, this);

    // prep the contents of the control
    if(this.options.type == 'replace'){
      this.button.appendChild(this._currentState.icon);
    } else {
      for(var i=0;i<this._states.length;i++){
        this.button.appendChild(this._states[i].icon);
      }
    }
  },


  _currentState: {
    // placeholder content
    stateName: 'unnamed',
    icon: (function(){ return document.createElement('span'); })()
  },



  _states: null, // populated on init



  state: function(newState){

    // when called with no args, it's a getter
    if (arguments.length === 0) {
      return this._currentState.stateName;
    }

    // activate by name
    if(typeof newState == 'string'){

      this._activateStateNamed(newState);

    // activate by index
    } else if (typeof newState == 'number'){

      this._activateState(this._states[newState]);
    }

    return this;
  },


  _activateStateNamed: function(stateName){
    for(var i = 0; i < this._states.length; i++){
      if( this._states[i].stateName == stateName ){
        this._activateState( this._states[i] );
      }
    }
  },

  _activateState: function(newState){

    if( newState === this._currentState ){

      // don't touch the dom if it'll just be the same after
      return;

    } else {

      // swap out elements... if you're into that kind of thing
      if( this.options.type == 'replace' ){
        this.button.appendChild(newState.icon);
        this.button.removeChild(this._currentState.icon);
      }

      if( newState.title ){
        this.button.title = newState.title;
      } else {
        this.button.removeAttribute('title');
      }

      // update classes for animations
      for(var i=0;i<this._states.length;i++){
        L.DomUtil.removeClass(this._states[i].icon, this._currentState.stateName + '-active');
        L.DomUtil.addClass(this._states[i].icon, newState.stateName + '-active');
      }

      // update classes for animations
      L.DomUtil.removeClass(this.button, this._currentState.stateName + '-active');
      L.DomUtil.addClass(this.button, newState.stateName + '-active');

      // update the record
      this._currentState = newState;

    }
  },

  enable: function(){
    L.DomUtil.addClass(this.button, 'enabled');
    L.DomUtil.removeClass(this.button, 'disabled');
    this.button.setAttribute('aria-hidden', 'false');
    return this;
  },

  disable: function(){
    L.DomUtil.addClass(this.button, 'disabled');
    L.DomUtil.removeClass(this.button, 'enabled');
    this.button.setAttribute('aria-hidden', 'true');
    return this;
  },

  onAdd: function(map){
    var bar = L.easyBar([this], {
      position: this.options.position,
      leafletClasses: this.options.leafletClasses
    });
    this._anonymousBar = bar;
    this._container = bar.container;
    return this._anonymousBar.container;
  },

  removeFrom: function (map) {
    if (this._map === map)
      this.remove();
    return this;
  },

});

L.easyButton = function(/* args will pass automatically */){
  var args = Array.prototype.concat.apply([L.Control.EasyButton],arguments);
  return new (Function.prototype.bind.apply(L.Control.EasyButton, args));
};

/*************************
 *
 * util functions
 *
 *************************/

// constructor for states so only curated
// states end up getting called
function State(template, easyButton){

  this.title = template.title;
  this.stateName = template.stateName ? template.stateName : 'unnamed-state';

  // build the wrapper
  this.icon = L.DomUtil.create('span', '');

  L.DomUtil.addClass(this.icon, 'button-state state-' + this.stateName.replace(/(^\s*|\s*$)/g,''));
  this.icon.innerHTML = buildIcon(template.icon);
  this.onClick = L.Util.bind(template.onClick?template.onClick:function(){}, easyButton);
}

function buildIcon(ambiguousIconString) {

  var tmpIcon;

  // does this look like html? (i.e. not a class)
  if( ambiguousIconString.match(/[&;=<>"']/) ){

    // if so, the user should have put in html
    // so move forward as such
    tmpIcon = ambiguousIconString;

  // then it wasn't html, so
  // it's a class list, figure out what kind
  } else {
      ambiguousIconString = ambiguousIconString.replace(/(^\s*|\s*$)/g,'');
      tmpIcon = L.DomUtil.create('span', '');

      if( ambiguousIconString.indexOf('fa-') === 0 ){
        L.DomUtil.addClass(tmpIcon, 'fa '  + ambiguousIconString)
      } else if ( ambiguousIconString.indexOf('glyphicon-') === 0 ) {
        L.DomUtil.addClass(tmpIcon, 'glyphicon ' + ambiguousIconString)
      } else {
        L.DomUtil.addClass(tmpIcon, /*rollwithit*/ ambiguousIconString)
      }

      // make this a string so that it's easy to set innerHTML below
      tmpIcon = tmpIcon.outerHTML;
  }

  return tmpIcon;
}

})();


/***/ }),

/***/ 30:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ })

}]);