(window["webpackJsonpmbase2modules"] = window["webpackJsonpmbase2modules"] || []).push([[30,17,19,22],{

/***/ 20:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){
	/**
	 * @param params {object} component parameters
	 * @param params.data {array<object>} initial data
	 * @param params.options {object} component options
	 */
	return function(options = {}) {

		var data = options.data || [];
		const op = options;
		const $el = $('<div/>');
		const badge = op.badge || op.label;
		const required = op.required ? 'required' : '';

		this.hasError = false;

		let $badge;
		
		if (badge){
			$badge = $(`<span class="label label-primary mbase2-label ${required}">`+badge+'</span>');
			$el.append($badge);
		}
		
		var key;
		
		if (data && data.key!==undefined){
			key=data.key;
			data=data.data;
		}
    
		if (op.valueTextPairData===true) {
		var _data=[];
		$.each(data,function(value,text){
			_data.push({value:value,text:text});
		});
		data=_data;
		}
		else if (Array.isArray(data[0])) {
			data = data.map(d => ({value: d[0], text: d[1], additional: d[2]}));
		}
		
		var $select=$('<select/>');
		var options="";
		for (var i=0,len=data.length;i<len;++i){
			var v=data[i];
			var val=v;
			var vtext=v;
      		if (op.textField!==undefined) v.text=v[op.textField];
			if (v.value!==undefined) val=v.value;
			if (v.text!==undefined) vtext=v.text;
			var optionData='';
			if (v.data!==undefined) optionData='data-data=\''+v.data+'\'';
			var additionalData = '';
			if (v.additional!==undefined) additionalData='data-additional=\''+v.additional+'\'';
			options+='<option '+optionData+ ' ' + additionalData + ' value="'+val+'">'+vtext+'</option>';
		}
		$select.html(options);
		
		if (op.multiple===true){
			$select.attr('multiple',"multiple");
		}
		
		$el.append($select);
		
		var selOp={width: '100%'};
		if (op.templateResult) selOp.templateResult=op.templateResult;
		if (op.templateSelection) selOp.templateSelection=op.templateSelection;
    
    if (op.placeholder) {
      selOp.placeholder=op.placeholder;
    }
    
    if (op.allowClear) {
      selOp.allowClear=true;
      selOp.placeholder=""; //workaround for some bug
    }
    
		if (op.tags===true){
		  selOp.tags=true;
	
		  if (op.createTag===undefined){
			selOp.createTag=function (params) {
					return {
					  id: params.term,
					  text: params.term,
					  newOption: true
					};
				  };
		  }
		  else{
			selOp.createTag=op.createTag;		
		  }
		  
		  selOp.templateResult = op.templateResult || function (data) {
				  var $result = $("<span></span>");
			  
				  $result.text(data.text);
			  
				  if (data.newOption) {
					$result.append(" <em>"+op.newOptionText+"</em>");
				  }
			  
				  return $result;
		  };
		}
	
		if (op.templateSelection) {
			selOp.templateSelection=op.templateSelection;
		}
		
		$select.select2(selOp);

		if (op.read_only) {
			$select.prop('disabled', true);
		}
    
		if (op.required===true) {
		  $el.data('required',"1");
		}

		this.onSelectHook = null;
		
		var onSelect=op.onSelect;
		$select.off('select2:select');
		$select.on('select2:select',function (e) {
			if (this.hasError && required && this.val()) {
				this.hasError = false;
				if ($badge) {
					$badge.removeClass('label-danger');
					$badge.addClass('label-primary');
				}
			}

			if (op.multiple && op.selectionSort === false) {
				//https://stackoverflow.com/questions/40763223/select2-multiselect-how-to-stop-automatic-sorting
				var element = e.params.data.element;
				var $element = $(element);

				$element.detach();
				$(this).append($element);
				$(this).trigger("change");
			}

			onSelect && onSelect(e);

			this.onSelectHook && this.onSelectHook(e);
		});

		op.onSelecting && $select.on('select2:selecting', op.onSelecting);

		op.onUnselect && $select.on('select2:unselect', op.onUnselect);

		$select.off('select2:close');
		op.onSelect2close && $select.on('select2:close', op.onSelect2close);
		
		var selectedValue=op.selectedValue;
		if (selectedValue===undefined) selectedValue=null;
		$select.val(selectedValue).trigger("change");
		
		if (selectedValue!==undefined && onSelect !== undefined && !op.silent) {
			$select.val() == selectedValue && onSelect(selectedValue);
		}

		this.emptyElement=function(){
			$el.empty();
		};
		this.getDataKey=function(){
			return key;
		};

		this.getOptionByValue = function(value) {
			return $select.find('option[value="'+value+'"]')[0];
		}

		this.getAdditionalDataForSelectedOption = function() {
			const op = this.getOptionByValue($select.val());
			if (!op) return null;
			const additional = op.attributes.item('additional');
			if (!additional) return null;
			return additional.value;
		}

		this.val=function(a,silent){
			if (a!==undefined){
				if (op.tags===true && $select.find('option[value="'+a+'"]').length===0){
				  var $opt=$('<option>'+a+'</option>');
				  $opt.attr('data-select2-tag','"true"');
				  $opt.val(a);
				  $select.append($opt);
				}
				$select.val(a).trigger("change");
				if (silent!==true && onSelect!==undefined) {
					$select.val() == a && onSelect(a); 
				}
			}
			return $select.val();
		};
		this.text=function(a,silent){
			if (a!==undefined){
				var id=$select.find('option').filter(function () { return $(this).html() == a; }).val();
				this.val(id,silent);
			}
			else{
				var id=$select.val();
				
				if (Array.isArray(id)) {
					return id.map(id => this.getTextFromID(id));
				}

				return this.getTextFromID(id);
			}
		};
		this.getData=function(){
			return $select.select2('data');
		};
		
		this.$select=$select;
		
		this.disabled=function(disabled){
			$select.prop('disabled',disabled);
		};
		
		this.reinit=function(data,textf){
			if (data.length===0) return false;
			if (textf===undefined) textf='text';
			var valf='id';
			if (data[0][valf]===undefined) valf=textf;
			var $tmpSelect=$('<select/>');
			
			if (data[0][valf] && data[0][textf]){
				$.each(data,function(key,op){
					$tmpSelect.append($('<option/>',{value:op[valf]}).text(op[textf]));
				});
			}
			else if (Array.isArray(data[0])) {
				data.map(d => {
					$tmpSelect.append($('<option/>',{value:d[0]}).text(d[1]));
				});
			}
			else{
				$.each(data,function(key,op){
					$tmpSelect.append($('<option/>',{value:op}).text(op));
				});
			}
			
			$select.html($tmpSelect.html()).val(null).trigger('change');
			return true;
		};
		
		this.getTextFromID=function(id){
			return $select.find('option[value="'+id+'"]').text();
		};
    
    this.$el=function(){
      return $el;
	};
	
	this.validate = function() {
		if (required && !this.val()) {
			this.hasError = true;
			if ($badge) {
				$badge.addClass('label-danger');
				$badge.removeClass('label-primary');
			}
			return false;
		}
		return true;
	};
    
    this.setError=function(className){
      this.$el().find('.select2.select2-container').addClass(className);
    };
    
    this.addOption=function(op){
      if (op.value===undefined) op={value:op,text:op};
      $select.append($('<option/>',{value:op.value}).text(op.text));
    };
		
		if (op.initialValue!==undefined){
			this.val(op.initialValue);
		}
		
	};
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ 21:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Accordion; });
const $panelGroup = id => $(`<div class="panel-group" id="${id}"></div>`);

const $panel = (parentId, title, index) =>
 $(`<div class="panel panel-default">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a data-toggle="collapse" data-parent="#${parentId}" href="#${parentId + '-' + index}">
          ${title}
        </a>
      </h4>
    </div>
    <div id="${parentId + '-' + index}" class="panel-collapse collapse in">
      <div class="panel-body">
         
      </div>
    </div>
  </div>`);

/**
 * @param {object} op options
 * @param {string} op.id component id
 * @param {boolean} op.closeOthers 
 * @param {array<string>} op.panels
 * @param {boolean} op.headingPointer=true mouse pointer over whole header
 */

function Accordion (op={}) {
  this.id = op.id || ('aid-'+Math.random()).replace('0.','');

  this.onPanelRemove = op.onPanelRemove;

  op.headingPointer = op.headingPointer === undefined ? true : op.headingPointer;

  const $el = $panelGroup(op.closeOthers === false ? "" : this.id);
  this.$el = () => $el;
  if (!op.panels) op.panels = [];

  this.panels = [];

  op.panels.map((title, index) => {
    this.addPanel(title, index)
  });

  if (op.headingPointer) {
    $el.find('.panel-heading').css('cursor','pointer').on('click', function() {
      $(this).parent().find('.panel-collapse:first').collapse('toggle');
      return false;
    });
  }

  this.$panelGroup = $el;

  if (op.$parent) {
    op.$parent.append(this.$el());
  }
}

Accordion.prototype.addPanel = function(title, index) {
  if (index === undefined) {
    index = this.panels.length;
  }

  let $pdiv = $panel(this.id, title, index);
  this.$el().append($pdiv);
  this.panels.push({
      title: title,
      $panel: $pdiv,
      $body: $pdiv.find('.panel-body')
  });

  if (this.onPanelRemove) {
    const $btn = $('<button style="margin-top:-0.9em" type="button" class="close" aria-hidden="true"><span class="pficon pficon-delete"></span></button>');
    $pdiv.find('.panel-heading:first').append($btn);
    $btn.on('click', () => this.onPanelRemove($pdiv, this.$el()));
  }

}

Accordion.prototype.getPanel = function(title) {
  return this.panels.find(p => p.title === title);
}



/***/ }),

/***/ 22:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Input", function() { return Input; });
function appendHiddenSubmitButtonToForm($form) {
    const $submit = $(`<button type="submit" class="btn btn-default">Submit</button>`);
    $submit.hide();
    $form.submit(function(event){
        // cancels the form submission
        event.preventDefault();
    });
    $form.append($submit);
    return $submit;
}

const Input = function (op = {}, _inputs = null) {

    const $form = this.$form = op.$form || $('<form/>');

    this.type = op.type ? op.type : 'text';

    const $formGroup = $(`<div class="${op.required ? 'required' : ''}"></div>`);

    const $label = $(`<span class="label label-primary mbase2-label">${op.label}</span>`);
    
    if (this.type !== 'checkbox') {
        op.label && $formGroup.append($label);
    }

    const readOnly = op.read_only === true ? 'readonly' : '';
    const min = op.min ? `min="${op.min}"` : '';
    const max = op.max ? `max="${op.max}"` : '';
    const $input = this.$input = op.type === 'select' ? 
        $(`<select></select>`) : 
        $(`<input ${min} ${max} ${readOnly} ${op.required ? 'required' : ''} type="${this.type}" class="form-control" id="${op.key}" placeholder="${op.placeholder ? op.placeholder : ''}">`);

    if (op.type === 'select') {
        op.options.map(value => $input.append(`<option value="${value}">${value}</option>`))
    }

    if (op.onChange) {
        $input.on('change', () => op.onChange(_inputs));
    }
    
    if (!op.key) {
        $input.removeAttr('id');
    }

    op.keyup && $input.on('keyup', op.keyup);
    op.keydown && $input.on('keydown', op.keydown);
    op.onpaste && $input.on("paste", op.onpaste);
    
    op.pattern && $input.attr('pattern', op.pattern);
    op.step && $input.attr('step', op.step);

    op.helpIconText && $formGroup.append(`&nbsp;<span class="pficon pficon-help" title="${op.helpIconText}"></span>`);

    $formGroup.append($input);

    this.$help = $(`<span class="help-block"></span>`);
    op.help && this.$help.text(op.help);
    $formGroup.append(this.$help);
    this.$error = $(`<span class="help-block has-error"></span>`);
    $formGroup.append(this.$error);

    if (this.type === 'checkbox') {
        const $label = $('<label/>');
        $input.removeClass('form-control');
        $label.append($input);
        $label.append(op.label);
        $formGroup.append($label);
        $formGroup.addClass('checkbox');
    }

    const validateControl = op.validate === undefined ? true : op.validate;
    
    if (validateControl) {
        const $submit = op.$form ? op.$form.find(':submit') : appendHiddenSubmitButtonToForm($form);
        
        $input.blur(function(event) {
            //event.target.checkValidity();
            $formGroup.removeClass('has-error');
            $label.removeClass('has-error');
            if ($input.css('display')==='none') return;
            $submit.click();
        }).bind('invalid', function(event) {
            $formGroup.addClass('has-error');
            $label.addClass('has-error');
            //setTimeout(function() { $(event.target).focus();}, 50);
            return false;
        });
    }

    $form.append($formGroup); 

    this.$el = () => op.$form ? $formGroup : $form;

    if (op.mask) {
        const maskOptions = Object.assign(op.mask.options || {}, {$input: $input});
        this.imask = new op.mask.component(maskOptions);
    }

    if (op.data!==undefined) {
        this.val(op.data);
    }
}

Input.prototype.validate = function(reportValidity = true) {
    if (reportValidity === true) {
        return this.$form[0].reportValidity();
    }
    else {
        return this.$form[0].checkValidity();
    }
}

Input.prototype.val = function(a) {
    
    if (a!==undefined) {

        if (this.type === 'checkbox') {
            this.$input.prop('checked', a);
        }
        else {
            this.$input.val(a);
        }

        if (this.imask) {
            this.imask.mask.value = a;
        }

    }

    let rval;
    if (this.type === 'checkbox') {
        rval = this.$input.prop('checked');
    }
    else {
        rval = this.$input.val();
    }

    if (['number', 'date', 'time'].indexOf(this.type) !== -1 && !rval) return null;   //numbers, date and time shuldn't return an empty string

    return rval;
}

const Inputs = function (op) {
    const $form = this.$form = $('<form/>');
    
    const validateForm = op.validate === undefined ? true : op.validate;

    if (validateForm) {
        appendHiddenSubmitButtonToForm($form);
    }
    
    this.inputs = {};

    let _inputs = [];

    if (Array.isArray(op.inputs)) {
        _inputs = op.inputs;
    }
    else if (typeof op.inputs === "function") {
        _inputs = op.inputs();
    }

    _inputs.map(_op => {
        const validateControl = _op.validate === undefined ? true : _op.validate;
        _op.validate = validateForm && validateControl;
        _op.$form = $form;
        const input = new Input(_op, this.inputs);
        this.inputs[_op.key] = input;
    });

    this.$el = () => $form;

    if (op.data) {
        this.val(op.data);
    }
}

Inputs.prototype.validate = function(reportValidity = true) {
    if (reportValidity === true) {
        return this.$form[0].reportValidity();
    }
    else {
        return this.$form[0].checkValidity();
    }
}

Inputs.prototype.val = function(values) {
    
    if (values!==undefined) {
        if (!values) {
            values = {};
            Object.keys(this.inputs).map(key => {
                values[key] = null;
            });
        }

        Object.keys(values).map(key => {
            this.inputs[key] && this.inputs[key].val(values[key]);
        });
        return values;
    }

    const rval = {};

    const self = this;
    Object.keys(this.inputs).map(key => {
        rval[key] = self.inputs[key].val();
    });

    return rval;
}

/* harmony default export */ __webpack_exports__["default"] = (Inputs);

/***/ }),

/***/ 52:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Inputs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(22);
/* harmony import */ var _Accordion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21);
/* harmony import */ var _Tselect2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20);
/* harmony import */ var _Tselect2__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_Tselect2__WEBPACK_IMPORTED_MODULE_2__);




/**
 * 
 * @param {object} op 
 * @param {boolean} op.revert give user possibility to revert the change
 */

function LocationSelector (op = {}) {
    const $el = $('<div/>', {
        style:"display:flex; height: 40em"
    });
    
    const $map = this.$map = $('<div/>', {
        style: "height:100%;width:50%"
    });

    const $coords = this.$coords = $('<div/>', {
        style: "width:50%; padding-left:15px"
    });

    this.op = op;

    if (this.op.revert) {
        this.$revert = $('<div/>');
        $coords.append(this.$revert);
    }

    const t = this.t = op.imports.t || (x => x[0]);

    const $requestResults = $('<div/>');

    //this variables

    this.$requestResults = $requestResults;

    this.$el = () => $el;
    
    this.value = {
        id: op.id || null,
        lat: null,
        lon: null,
        _uninitialized: true 
    };

    const self = this;

    const crs = this.crsCmp = new op.imports.Select2.default({
        label: t`Koordinatni sistem`,
        onSelect: crs => {
            const {lat, lon} = self.value;

            crs = crs && crs.params && crs.params.data.id;

            if (!crs || !lat || !lon) return;

            self.val({lat: lat, lon: lon}, false, 4326, true, true);
            
            self.updateFields(crs);
        },
        data: [
            [3912, 'EPSG:3912 D48/GK – jugoslovanski geodetski datum 1948, sistem dvorazsežnih kartezičnih koordinat – Gauß-Krügerjeva projekcija'],
            [4326, 'EPSG:4326 WGS84/φλ – GPS - geodetski datum WGS84, sistem dvorazsežnih geodetskih/elipsoidnih koordinat'],
            [3794, 'EPSG 3794 - D96/TM – slovenski geodetski datum 1996, sistem dvorazsežnih kartezičnih koordinat – prečna Mercatorjeva projekcija']
        ]}
    );

    crs.val(this.op.defaultCRS || 4326);

    $coords.append(crs.$el());

    this.spatialRequest = op.spatialRequest;

    if (!this.spatialRequest && op.defaultSpatialRequest) {
        this.spatialRequest = (lat, lon, $el) => {
            return op.imports.mutils.requestHelper(op.defaultSpatialRequest.apiRoot + `/geom/spatial_units?:lat=${lat}&:lon=${lon}`,'GET', null, {}, $el);
        }
    }

    this._locations_table = op._locations_table;

    $el.append($map);

    if (op.panels) {
        const acc = new _Accordion__WEBPACK_IMPORTED_MODULE_1__["default"]({$parent: $el, closeOthers: true});
        acc.addPanel('Coordinate location');
        acc.getPanel('Coordinate location').$body.html($coords);
        acc.$el().css('margin-left','15px').css('width', '49%');
        $el.append(acc.$el());
    }
    else {
        $el.append($coords);
    }

    op.$parent.append($el);

    this.inputs = new _Inputs__WEBPACK_IMPORTED_MODULE_0__["default"]({

        inputs:[
            {
                key: 'lat',
                label: t`Latitude (north)`,
                type: 'text',
                //step: 0.000001,
                keydown: onKeyDown,
                keyup: removeLeadingZero,
                onpaste: onPaste
            },
            {
                key: 'lon',
                label: t`Longitude (east)`,
                type: 'text',
                //step: 0.000001,
                keydown: onKeyDown,
                keyup: removeLeadingZero,
                onpaste: onPaste
            }
        ]
    });

    function onPaste(e) {

        let pastedText = e.originalEvent.clipboardData.getData('text');

        pastedText = pastedText.replace(/,/g, '.');

        const value = parseFloat(pastedText);

        if (!isNaN(value)) {
            const currentText = $(this).attr('value').trim();
            if (currentText) {//if there is alread some content
                if (currentText.includes('.') && pastedText.includes('.')) {
                    return false;
                }
                return true; 
            }

            $(this).attr('value', pastedText);
            return false;
        }

        return false;
    }

    function removeLeadingZero(e) {
        const $this = $(this);

        const value = $this.attr('value');

        if (value && value[0] === '0') {
            $this.attr('value', value.substring(1));
        }
    }

    function onKeyDown(e) {
        
        if (e.ctrlKey) return true;

        if (e.which < 32 || ['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Insert','Delete','PageUp','PageDown','Home','End'].indexOf(e.key) !==-1) return true;

        const allowedKeys = [0,1,2,3,4,5,6,7,8,9,',','.'].map(key=>key+'');
        if (allowedKeys.indexOf(e.key)===-1) return false;

        const $this = $(this);

        if (e.key==='0' && $this.attr('value').length === 0) {//no leading zero
            return false; 
        }

        const cval = $this.val();

        if (e.key===',' || e.key === '.') {
            if (cval.includes('.')) return false; //only one decimal allowed
            
            $this.attr('value', cval + '.');
            
            return false;
        }
        
        //$(this).val(cval);
    }

    this.inputs.$el().on('keyup', manualEntry);

    this.projected = {
        raw:{},
        formatted:{}
    };

    if (this.spatialRequest) {
        const btn = new op.imports.Button.default({
            label: t`Posodobi prostorske podatke`,
            onClick: () => this.updateFields()
        });

        this.$requestButton = btn.$el();
        this.$requestButton.css('margin-top','15px');
    }
    
    $coords.append(this.inputs.$el());

    const _inputs = [];

    this.op.distanceFromSettlement && _inputs.push({
        key: 'sdist',
        //label: t`Oddaljenost od naselja (hiše) v metrih`
        label: t`Distance from settlement (house) in meters`
    });

    this.op.localName && _inputs.push({
        key: 'lname',
        label: t`Local name`
    });

    this.op.locationType && _inputs.push({
        key: 'ltype',
        label: t`Location type`,
        type: 'select',
        options: [
            'no location',
            'no data',
            'GPS',
            'grid',
            'hunting area',
            'toponym'
        ],
        data:''
    });

    const inputs = this.additional = new _Inputs__WEBPACK_IMPORTED_MODULE_0__["default"]({
        inputs: _inputs
    });

    if (this.$requestButton) {
        this.$requestButton.hide();
        $coords.append(this.$requestButton);
    }

    $coords.append(this.$requestResults);

    $coords.append('<hr>');

    $coords.append(inputs.$el());

    function manualEntry() {
        hidePopup();
        const c = self.inputs.val();
        if (!c.lat || !c.lon) return;
        const sprememba = (!self.value || (Math.abs(c.lat - self.value.lat) > 1e-6) || (Math.abs(c.lon - self.value.lon) > 1e-6)) ? true : false;   //have coordiantes changed?
        
        self.val(c,false, crs.val(), true, true);

        self.showPopup(self.value);

        if (sprememba) {
            self.$requestResults.empty();
            self.$requestButton && self.$requestButton.show();
        }

       /*//zaenkrat ne bom omejil območja vnosa
        //
        //  WGS84 bounds: 13.2 45.3, 16.7 47
        //  32000 370000, 195000 623000 
        //
       const crs = self.crs.val();
       if (crs == 4326) {
        if (c.lon > 13.2 && c.lon < 16.7 && c.lat > 45.3 && c.lat < 47) {
            self.val(c);
        }
       }
       else {
           
       }
       */
    }

    //init leaflet map

    const map = L.map($map[0],{ zoomControl: false }).setView([46.119944, 14.81533], 8);
    new L.Control.Zoom({ position: 'bottomright' }).addTo(map);
    this.map = map;

    this.popup = L.popup();

    map.on('click', e => {
        const c = {
            lat: e.latlng.lat,
            lon: e.latlng.lng
        }
        self.val(c, false);
        self.showPopup(c);

        self.updateFields();
    });

    function hidePopup() {
        map.closePopup();
    }

    const baseMaps = {
        "OpenStreetMap": L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
          attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
        }),
        "DOF": L.tileLayer.wms("http://prostor4.gov.si:80/ows2-m-pub/wms?", {
          layers:"SI.GURS.ZPDZ:DOF050",
          attribution: '<a href="http://www.e-prostor.gov.si/dostop-do-podatkov/dostop-do-podatkov/#c501">Geodetska uprava Republike Slovenije</a>'
        })
      };
  
    const overlays = {
    "Občine":  L.tileLayer.wms("http://prostor4.gov.si:80/ows2-m-pub/wms?", {
        layers:"table_gurs_pub:SI.GURS.RPE.LS",
        format: "image/png",
        transparent: "true",
        attribution: '<a href="http://www.e-prostor.gov.si/dostop-do-podatkov/dostop-do-podatkov/#c501">Geodetska uprava Republike Slovenije</a>'
    })
    };

    L.control.layers(baseMaps, overlays).addTo(this.map);

    baseMaps['OpenStreetMap'].addTo(this.map);
}

LocationSelector.prototype.showPopup = function(c) {
    if (c && c.lat && c.lon) {
        this.popup
        .setLatLng([c.lat, c.lon])
        .setContent(this.projectedMessage)
        .openOn(this.map);
    }
}

function projections(self, value, crs = 4326) {

    const pdefs = {
        3794: '+proj=tmerc +lat_0=0 +lon_0=15 +k=0.9999 +x_0=500000 +y_0=-5000000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs',
        3912: '+proj=tmerc +lat_0=0 +lon_0=15 +k=0.9999 +x_0=500000 +y_0=-5000000 +ellps=bessel +towgs84=409.545,72.164,486.872,3.085957,5.469110,-11.020289,17.919665 +units=m +no_defs',
        4326: '+proj=longlat +datum=WGS84 +no_defs'
    };

    let {lat, lon} = value;
    let projectTo = [3912, 3794];

    if (crs != 4326) {
        self.projected.raw[crs] = [lon, lat].map(c => parseFloat(c));

        //project to 4326
        const pdef = pdefs[crs];
        const lonlat = proj4(pdef, pdefs[4326], [ lon, lat].map(c => parseFloat(c)));
        lon = lonlat[0];
        lat = lonlat[1];

        projectTo = projectTo.filter(fcrs => fcrs != crs)
    }

    projectTo.map(crs => {
        self.projected.raw[crs] = proj4(pdefs[crs], [ lon, lat].map(c => parseFloat(c)));
    });

    self.projected.formatted[4326] = [lat, lon].map(c => parseFloat(c).toFixed(6));
    self.projected.formatted[3912] = self.projected.raw[3912].reverse().map(c => c.toFixed(2));
    self.projected.formatted[3794] = self.projected.raw[3794].reverse().map(c => c.toFixed(2));

    self.projectedMessage = `<b>EPSG:4326 - WGS84/φλ:</b> ${self.projected.formatted[4326].toString()}
                            <br>
                            <b>EPSG:3912 - D48/GK:</b> ${self.projected.formatted[3912].toString()}
                            <br>
                            <b>EPSG 3794 - D96/TM:</b> ${self.projected.formatted[3794].toString()}`;

    return {lat,lon};
}
LocationSelector.prototype.updateFields = function(crsCode = null) {

    const _updateFields = (crs) => {
        this.inputs.val({
            lat: this.value.lat ? this.projected.formatted[crs][0] : null,
            lon: this.value.lon ? this.projected.formatted[crs][1] : null
        });
    
        this.showPopup(this.value);
    
        this.$el().trigger('change');
    }

    if (crsCode) {
        _updateFields(crsCode);
        return;
    }

    const self = this;
    const crs = this.crsCmp;

    if (self.spatialRequest) {
        self.$requestButton.hide();
        self.$requestResults.html('<hr>');

        const $container = $(`<div class="alert alert-info">
            <span class="pficon pficon-info"></span>
        </div>`);

        if (self.value.lat && self.value.lon) {
            self.spatialRequest(self.value.lat, self.value.lon, self.$el()).then(res => {
                self.spatial_request_result = {};
                _updateFields(crs.val());
                self.processSpatialRequest(res, $container);
                self.op.onSpatialRequestFinished && self.op.onSpatialRequestFinished(res);
            });
        }
    }
    else {
        _updateFields(crs.val());
    }
}

LocationSelector.prototype.processSpatialRequest = function (res, $container) {
    const self = this;

    if (!self.spatial_request_result) self.spatial_request_result = {};

    if (res && res[0]) {
        const keys = [
            {
                key_name_id: 'ob_uime',
                t_name_id: 'Občina'
            },
            {
                key_name_id: 'oe_ime',
                t_name_id: 'OE ZGS'
            },
            {
                key_name_id: 'luo_ime',
                t_name_id: 'LUO'
            },
            {
                key_name_id: 'lov_ime',
                t_name_id: 'Ime lovišča'
            }
        ];
        keys.map(key => {
            const value = res[0][key.key_name_id];
            self.spatial_request_result[key.key_name_id] = value;
            $container && $container.append(`
                <strong>${key.t_name_id}: </strong> ${value}<br>
            `);
        });

        $container && self.$requestResults.append($container);
    }
}

LocationSelector.prototype.val = function(value, updateFields = true, crsCode = 4326, skipConfirm=false, skipRevert=false) {
    if (value !== undefined) {
        
        const t = this.t;

        if (!skipConfirm && !this.value._uninitialized && this.op.confirmChange) {
            if (!confirm (t`The coordinates have changed - click OK if this was done on purpose.`)) return;
        }

        if (!skipRevert && !this.value._uninitialized && this.op.revert) {
            const $alert = $(`<div class="alert alert-warning">
                <span class="pficon pficon-warning-triangle-o"></span>
            </div>`);

            this.previousValue = Object.assign({}, this.val(undefined, false));

            const $msg = $('<div>The value has been changed. Click </div>');
            const $here = $('<a href="#"><b>' + t`here` + '</b></a>');
            $msg.append($here);
            $msg.append(' ');
            $msg.append(t`to revert`);
            $msg.append('.');

            $here.on('click', () => {
                this.val(this.previousValue, true, 4326, true);
                this.$revert.empty();
                return false;
            });

            $alert.append($msg);

            this.$revert.html($alert);
        }

        delete this.value._uninitialized;
        
        if (value === null || value.lat === null || value.lon === null) {
            this.value = {
                id: null,
                lat: null,
                lon: null
            };
        }
        else {
            this.value.id = value.id;
            if (value.crs && value.crs != crsCode) crsCode = value.crs;
            const {lat, lon} = projections(this, value, crsCode); 
            this.value.lat = lat;
            this.value.lon = lon;
        }

        if (value && value.spatial_request_result) {
            this.spatial_request_result = Object.assign({},value.spatial_request_result);
        }

        if (value && value.additional) {
            this.additional.val(value.additional);
        }

        if (updateFields) {
            this.updateFields();
        }
    }
    
    if (this.spatial_request_result) {
        this.value.spatial_request_result = Object.assign({},this.spatial_request_result);
    }

    this.value.additional = Object.assign({},this.additional.val());

    if (this._locations_table) this.value._locations_table = this._locations_table;

    if (this.value.id===undefined) delete this.value['id'];

    return this.value;
}

/* harmony default export */ __webpack_exports__["default"] = (LocationSelector);

/***/ })

}]);