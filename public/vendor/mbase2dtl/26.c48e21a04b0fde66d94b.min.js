(window["webpackJsonpmbase2modules"] = window["webpackJsonpmbase2modules"] || []).push([[26],{

/***/ 16:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "leafletPreview", function() { return leafletPreview; });
/* harmony import */ var leaflet_easybutton__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29);
/* harmony import */ var leaflet_easybutton__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet_easybutton__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var leaflet_easybutton_src_easy_button_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);
/* harmony import */ var leaflet_easybutton_src_easy_button_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(leaflet_easybutton_src_easy_button_css__WEBPACK_IMPORTED_MODULE_1__);

  
  

  //https://gis.stackexchange.com/questions/197882/is-it-possible-to-cluster-polygons-in-leaflet
	L.PolygonClusterable = L.Polygon.extend({
	  _originalInitialize: L.Polygon.prototype.initialize,
	  
	  initialize: function (bounds, options) {
		this._originalInitialize(bounds, options);
		this._latlng = this.getBounds().getCenter();
	  },
	  
	  getLatLng: function () {
		return this._latlng;
	  },
	  
	  // dummy method.
	  setLatLng: function () {}
	});

  const pdefs = {
    3794: '+proj=tmerc +lat_0=0 +lon_0=15 +k=0.9999 +x_0=500000 +y_0=-5000000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs',
    3912: '+proj=tmerc +lat_0=0 +lon_0=15 +k=0.9999 +x_0=500000 +y_0=-5000000 +ellps=bessel +towgs84=409.545,72.164,486.872,3.085957,5.469110,-11.020289,17.919665 +units=m +no_defs',
    4326: '+proj=longlat +datum=WGS84 +no_defs',
    3035: '+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs'
  };

  /**
   * 
   * @param {boolean} centerPopupOnOpen 
   */
  var Map=function(op = {}){
    this.op=op;
    const center = this.op.center || [46.119944, 14.81533];
    const zoom = this.op.zoom || 8;

    this.$el = () => op.$container;

    this.$el().css('font-size','11px'); //temporary solution for patternfly css interference with leaflet font size

    this.__state = 'detail';

    const mapOptions = { zoomControl: false, preferCanvas: true };

    if (op.zoomDelta !== undefined) mapOptions.zoomDelta = op.zoomDelta;
    if (op.zoomSnap !== undefined) mapOptions.zoomSnap = op.zoomSnap;

    const map = this.map = L.map(this.op.$container[0], mapOptions).setView(center, zoom);

    const baseMaps = {
      "OpenStreetMap": L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
      })
    };

    /*
    baseMaps.DOF = L.tileLayer.wms("http://prostor4.gov.si:80/ows2-m-pub/wms?", {
      layers:"SI.GURS.ZPDZ:DOF050",
      maxNativeZoom: 19,
      maxZoom: 23,
      attribution: '<a href="http://www.e-prostor.gov.si/dostop-do-podatkov/dostop-do-podatkov/#c501">Geodetska uprava Republike Slovenije</a>'
    });
    */

    const mbAttr = 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community';

    const mbUrl = 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}';

    baseMaps['ESRI World Imagery'] = L.tileLayer(mbUrl, {
      id: 'esri',
      attribution: mbAttr
    });

    const overlays = {};

    L.control.layers(baseMaps, overlays).addTo(map);

    baseMaps['OpenStreetMap'].addTo(map);

    op.scaleControl && L.control.scale({
      position: 'bottomright'
    }).addTo(map);

    new L.Control.Zoom({ position: 'bottomright' }).addTo(map);

    if (op.stateChangingButton) {
      map.stateChangingButton = L.easyButton({
        position:'topright',
        id:'grid-detail-switch',
        states: [{
          stateName: 'detail',
          icon:      'fa-th',
          title:     op.stateChangingButton.detail.title,
          onClick: (btn, map) => this.switchState(btn, map, 'grid')
        },
        {
          stateName: 'grid',        // name the state
          icon:      'fa-map-marker',               // and define its properties
          title:     op.stateChangingButton.grid.title,      // like its title
          onClick: (btn, map) => this.switchState(btn, map, 'detail')
        }
      ]
      }).addTo(map);
    }

	};

  Map.prototype.switchState=function(btn,map,state) {
    if (btn === null) btn = this.map.stateChangingButton;
		if (map === null) map = this.map;
		btn.state(state);
    this.__state = state;
    this.op.onSwitchState && this.op.onSwitchState(state);
  }
  
  Map.prototype.addSidebar=function(sidebarId){
    return L.control.sidebar(sidebarId).addTo(this.map);
  };

  Map.prototype.zoomToMarker = function (marker, data) {
    const markerClusterGroup = this.layerGroup;

    const visibleParent = markerClusterGroup.getVisibleParent(marker); //returns marker if visible

    if (visibleParent === marker) {
        this.op.onMarkerClicked(marker, data);
        marker.openPopup();
    }
    else {
      if (this.map.getZoom()<this.map.getMaxZoom()) { //prevent endless loop in case visibleParent === marker condition is not reached (for example when we have two markers at the same spot)
        this.map.setView(marker.getLatLng(), this.map.getZoom()+1, true);
        setTimeout(() => this.zoomToMarker(marker,data),20)
      }
    }
    
}


  Map.prototype.getGridCellCoordinates = function(c, gridCellSize=1000) {
    
    if (!gridCellSize) gridCellSize=1000;

    const c0 = proj4(pdefs['3035'], pdefs['4326'], [c[1], c[0]]);
    return [c0,
        proj4(pdefs['3035'], pdefs['4326'], [c[1]+gridCellSize, c[0]]),
        proj4(pdefs['3035'], pdefs['4326'], [c[1]+gridCellSize, c[0]+gridCellSize]),
        proj4(pdefs['3035'], pdefs['4326'], [c[1], c[0]+gridCellSize]),
      c0].map(c => [c[1], c[0]]);
  }
  
  /**
   * 
   * Adds data array layer to map and assigns __marker reference to each row of the data
   * 
   * @param {Object[]} res coordinates, two types of input 
   * @param {string} [res[].geom]
   * @param {number} [res[]]
   * @param {string} moduleName module key
   * @param {string} state 'grid' or 'detail', if null this.__state is used
   * @param {Object} [props]
   * @param {string} props.grid_size grid size in meters
   * @param {string} props.color hex value of grid cell color (e.g. "#d211ec") 
   * @returns 
   */

  Map.prototype.addLayer = function(res, moduleName, state = null, props={}) {
    if (state!==null) this.__state = state;
    
    const layerGroup = this.layerGroup = this.__state==='grid' ? L.layerGroup() : L.markerClusterGroup();

    const markers = [];

    res.map(r => {
      let c = null;
      if (r.geom) {
        const geom = JSON.parse(r.geom);
        c = geom.coordinates.reverse();
      }
      else if (r.c) {
        c = r.c;
      }

      let marker = null;

      if (this.__state==='grid') { //create grid cells
        
        const cellc = this.getGridCellCoordinates(c, props && parseFloat(props.grid_size));

          const clsFun = L.Polygon; //clsFun = L.PolygonClusterable;
          const layerOptions = {};

          if (props && props.color) {
            layerOptions.color = props.color;
          }

          marker = new clsFun(cellc, layerOptions);
            //https://en.wikipedia.org/wiki/Alpha_compositing
            //polygon.setStyle({fillOpacity: 1.0 - 0.5/(detail.__cnt?detail.__cnt:1), fillColor: fillColor,color:fillColor});
      }
      else {
        marker = L.marker(c);
      }

      marker.bindPopup();

      r.__marker = marker;

      if (this.op.onMarkerClicked) {
        marker.on('click', () => this.op.onMarkerClicked(marker,r.data || r, moduleName));
      }
      
      c && markers.push(marker) && layerGroup.addLayer(marker);
  });
    
    this.map.addLayer(layerGroup);

    const self = this;

    if (this.op.centerPopupOnOpen || this.op.onPopupOpened) {
      
      layerGroup.on('popupopen', function(e) {

        if (self.op.centerPopupOnOpen) {
          setTimeout(() => {
              e.popup.update();
              setTimeout(() => {
                  const popupPosition = e.popup.getLatLng();
                  const mapCenter = self.map.getCenter();
                  self.map.panTo({lat: mapCenter.lat, lng: popupPosition.lng});
              }, 300);
          }, 100);
        }

        self.op.onPopupOpened && self.op.onPopupOpened(e, moduleName);
      });
    }

    return {markers,group:layerGroup};
  }

  const leafletPreview = (map, $map, src, props) => {
    if (!props.height || !props.width) return null;
    if (!map) {
      map = L.map($map[0], {
          crs: L.CRS.Simple,
          minZoom: 1,
          maxZoom: 5,
          center: [0, 0],
          zoom: 1,
          zoomDelta: 0.25,
          zoomSnap: 0
      });

      L.easyButton('fa-download', function(btn, map){
        downloadImage();
      }).addTo(map);

      L.easyButton('<span style="font-size: 1.5em;">&target;</span>', function(btn, map){
        fitBounds();
      }, 'Reset to initial view').addTo(map);
    }
    
    function downloadImage() {
      var a = $("<a>")
          .attr("href", src + '/' + props.type)
          .attr("download", "img." + props.type)
          .appendTo("body");

      a[0].click();

      a.remove();
    }
                
    const h = props.height;
    const w = props.width;
    var southWest = map.unproject([0, h], map.getMaxZoom()-1);
    var northEast = map.unproject([w, 0], map.getMaxZoom()-1);
    var bounds = new L.LatLngBounds(southWest, northEast);

    map.eachLayer(function (layer) {
        map.removeLayer(layer);
    });

    //var bounds = [[0,0], [props.height, props.width]];
    var image = L.imageOverlay(src, bounds).addTo(map);

    function fitBounds() {
      map.fitBounds(bounds);
    }
    
    fitBounds();

    return map;
}
  
  /* harmony default export */ __webpack_exports__["default"] = (Map);

/***/ }),

/***/ 29:
/***/ (function(module, exports) {

(function(){

// This is for grouping buttons into a bar
// takes an array of `L.easyButton`s and
// then the usual `.addTo(map)`
L.Control.EasyBar = L.Control.extend({

  options: {
    position:       'topleft',  // part of leaflet's defaults
    id:             null,       // an id to tag the Bar with
    leafletClasses: true        // use leaflet classes?
  },


  initialize: function(buttons, options){

    if(options){
      L.Util.setOptions( this, options );
    }

    this._buildContainer();
    this._buttons = [];

    for(var i = 0; i < buttons.length; i++){
      buttons[i]._bar = this;
      buttons[i]._container = buttons[i].button;
      this._buttons.push(buttons[i]);
      this.container.appendChild(buttons[i].button);
    }

  },


  _buildContainer: function(){
    this._container = this.container = L.DomUtil.create('div', '');
    this.options.leafletClasses && L.DomUtil.addClass(this.container, 'leaflet-bar easy-button-container leaflet-control');
    this.options.id && (this.container.id = this.options.id);
  },


  enable: function(){
    L.DomUtil.addClass(this.container, 'enabled');
    L.DomUtil.removeClass(this.container, 'disabled');
    this.container.setAttribute('aria-hidden', 'false');
    return this;
  },


  disable: function(){
    L.DomUtil.addClass(this.container, 'disabled');
    L.DomUtil.removeClass(this.container, 'enabled');
    this.container.setAttribute('aria-hidden', 'true');
    return this;
  },


  onAdd: function () {
    return this.container;
  },

  addTo: function (map) {
    this._map = map;

    for(var i = 0; i < this._buttons.length; i++){
      this._buttons[i]._map = map;
    }

    var container = this._container = this.onAdd(map),
        pos = this.getPosition(),
        corner = map._controlCorners[pos];

    L.DomUtil.addClass(container, 'leaflet-control');

    if (pos.indexOf('bottom') !== -1) {
      corner.insertBefore(container, corner.firstChild);
    } else {
      corner.appendChild(container);
    }

    return this;
  }

});

L.easyBar = function(){
  var args = [L.Control.EasyBar];
  for(var i = 0; i < arguments.length; i++){
    args.push( arguments[i] );
  }
  return new (Function.prototype.bind.apply(L.Control.EasyBar, args));
};

// L.EasyButton is the actual buttons
// can be called without being grouped into a bar
L.Control.EasyButton = L.Control.extend({

  options: {
    position:  'topleft',       // part of leaflet's defaults

    id:        null,            // an id to tag the button with

    type:      'replace',       // [(replace|animate)]
                                // replace swaps out elements
                                // animate changes classes with all elements inserted

    states:    [],              // state names look like this
                                // {
                                //   stateName: 'untracked',
                                //   onClick: function(){ handle_nav_manually(); };
                                //   title: 'click to make inactive',
                                //   icon: 'fa-circle',    // wrapped with <a>
                                // }

    leafletClasses:   true,     // use leaflet styles for the button
    tagName:          'button',
  },



  initialize: function(icon, onClick, title, id){

    // clear the states manually
    this.options.states = [];

    // add id to options
    if(id != null){
      this.options.id = id;
    }

    // storage between state functions
    this.storage = {};

    // is the last item an object?
    if( typeof arguments[arguments.length-1] === 'object' ){

      // if so, it should be the options
      L.Util.setOptions( this, arguments[arguments.length-1] );
    }

    // if there aren't any states in options
    // use the early params
    if( this.options.states.length === 0 &&
        typeof icon  === 'string' &&
        typeof onClick === 'function'){

      // turn the options object into a state
      this.options.states.push({
        icon: icon,
        onClick: onClick,
        title: typeof title === 'string' ? title : ''
      });
    }

    // curate and move user's states into
    // the _states for internal use
    this._states = [];

    for(var i = 0; i < this.options.states.length; i++){
      this._states.push( new State(this.options.states[i], this) );
    }

    this._buildButton();

    this._activateState(this._states[0]);

  },

  _buildButton: function(){

    this.button = L.DomUtil.create(this.options.tagName, '');

    if (this.options.tagName === 'button') {
        this.button.setAttribute('type', 'button');
    }

    if (this.options.id ){
      this.button.id = this.options.id;
    }

    if (this.options.leafletClasses){
      L.DomUtil.addClass(this.button, 'easy-button-button leaflet-bar-part leaflet-interactive');
    }

    // don't let double clicks and mousedown get to the map
    L.DomEvent.addListener(this.button, 'dblclick', L.DomEvent.stop);
    L.DomEvent.addListener(this.button, 'mousedown', L.DomEvent.stop);
    L.DomEvent.addListener(this.button, 'mouseup', L.DomEvent.stop);

    // take care of normal clicks
    L.DomEvent.addListener(this.button,'click', function(e){
      L.DomEvent.stop(e);
      this._currentState.onClick(this, this._map ? this._map : null );
      this._map && this._map.getContainer().focus();
    }, this);

    // prep the contents of the control
    if(this.options.type == 'replace'){
      this.button.appendChild(this._currentState.icon);
    } else {
      for(var i=0;i<this._states.length;i++){
        this.button.appendChild(this._states[i].icon);
      }
    }
  },


  _currentState: {
    // placeholder content
    stateName: 'unnamed',
    icon: (function(){ return document.createElement('span'); })()
  },



  _states: null, // populated on init



  state: function(newState){

    // when called with no args, it's a getter
    if (arguments.length === 0) {
      return this._currentState.stateName;
    }

    // activate by name
    if(typeof newState == 'string'){

      this._activateStateNamed(newState);

    // activate by index
    } else if (typeof newState == 'number'){

      this._activateState(this._states[newState]);
    }

    return this;
  },


  _activateStateNamed: function(stateName){
    for(var i = 0; i < this._states.length; i++){
      if( this._states[i].stateName == stateName ){
        this._activateState( this._states[i] );
      }
    }
  },

  _activateState: function(newState){

    if( newState === this._currentState ){

      // don't touch the dom if it'll just be the same after
      return;

    } else {

      // swap out elements... if you're into that kind of thing
      if( this.options.type == 'replace' ){
        this.button.appendChild(newState.icon);
        this.button.removeChild(this._currentState.icon);
      }

      if( newState.title ){
        this.button.title = newState.title;
      } else {
        this.button.removeAttribute('title');
      }

      // update classes for animations
      for(var i=0;i<this._states.length;i++){
        L.DomUtil.removeClass(this._states[i].icon, this._currentState.stateName + '-active');
        L.DomUtil.addClass(this._states[i].icon, newState.stateName + '-active');
      }

      // update classes for animations
      L.DomUtil.removeClass(this.button, this._currentState.stateName + '-active');
      L.DomUtil.addClass(this.button, newState.stateName + '-active');

      // update the record
      this._currentState = newState;

    }
  },

  enable: function(){
    L.DomUtil.addClass(this.button, 'enabled');
    L.DomUtil.removeClass(this.button, 'disabled');
    this.button.setAttribute('aria-hidden', 'false');
    return this;
  },

  disable: function(){
    L.DomUtil.addClass(this.button, 'disabled');
    L.DomUtil.removeClass(this.button, 'enabled');
    this.button.setAttribute('aria-hidden', 'true');
    return this;
  },

  onAdd: function(map){
    var bar = L.easyBar([this], {
      position: this.options.position,
      leafletClasses: this.options.leafletClasses
    });
    this._anonymousBar = bar;
    this._container = bar.container;
    return this._anonymousBar.container;
  },

  removeFrom: function (map) {
    if (this._map === map)
      this.remove();
    return this;
  },

});

L.easyButton = function(/* args will pass automatically */){
  var args = Array.prototype.concat.apply([L.Control.EasyButton],arguments);
  return new (Function.prototype.bind.apply(L.Control.EasyButton, args));
};

/*************************
 *
 * util functions
 *
 *************************/

// constructor for states so only curated
// states end up getting called
function State(template, easyButton){

  this.title = template.title;
  this.stateName = template.stateName ? template.stateName : 'unnamed-state';

  // build the wrapper
  this.icon = L.DomUtil.create('span', '');

  L.DomUtil.addClass(this.icon, 'button-state state-' + this.stateName.replace(/(^\s*|\s*$)/g,''));
  this.icon.innerHTML = buildIcon(template.icon);
  this.onClick = L.Util.bind(template.onClick?template.onClick:function(){}, easyButton);
}

function buildIcon(ambiguousIconString) {

  var tmpIcon;

  // does this look like html? (i.e. not a class)
  if( ambiguousIconString.match(/[&;=<>"']/) ){

    // if so, the user should have put in html
    // so move forward as such
    tmpIcon = ambiguousIconString;

  // then it wasn't html, so
  // it's a class list, figure out what kind
  } else {
      ambiguousIconString = ambiguousIconString.replace(/(^\s*|\s*$)/g,'');
      tmpIcon = L.DomUtil.create('span', '');

      if( ambiguousIconString.indexOf('fa-') === 0 ){
        L.DomUtil.addClass(tmpIcon, 'fa '  + ambiguousIconString)
      } else if ( ambiguousIconString.indexOf('glyphicon-') === 0 ) {
        L.DomUtil.addClass(tmpIcon, 'glyphicon ' + ambiguousIconString)
      } else {
        L.DomUtil.addClass(tmpIcon, /*rollwithit*/ ambiguousIconString)
      }

      // make this a string so that it's easy to set innerHTML below
      tmpIcon = tmpIcon.outerHTML;
  }

  return tmpIcon;
}

})();


/***/ }),

/***/ 30:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ })

}]);